{"version":3,"file":"default-src_app_cache_service_ts.js","mappings":"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AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,2CAA2C;AACtD;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;AC9CA;;AACblD,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkD,SAAT,CAAmBC,QAAnB,EAA6BC,SAA7B,EAAwC;AACpC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACC,SAAZ,CAAsBC,QAAtB,EAAgCC,SAAhC,EAA2C,IAA3C,CAAP;AACH;;AACDvD,iBAAA,GAAoBqD,SAApB;;;;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;ACtCD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,mBAAmB;;;;;;;;;;;;AChDN;;AACbvD,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIG,wBAAwB,GAAGH,mBAAO,CAAC,wCAAD,CAAtC;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqD,UAAT,CAAoBC,cAApB,EAAoC;AAChC,MAAIC,MAAM,GAAGC,SAAS,CAACD,MAAvB;AACA,MAAIH,SAAS,GAAGrD,MAAM,CAAC6C,cAAvB;;AACA,MAAIzC,wBAAwB,CAACsD,WAAzB,CAAqCD,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAA9C,CAAJ,EAA2E;AACvEH,IAAAA,SAAS,GAAGI,SAAS,CAACA,SAAS,CAACD,MAAV,GAAmB,CAApB,CAArB;AACAA,IAAAA,MAAM;AACT;;AACD,MAAIG,sBAAsB,GAAG,IAA7B;;AACA,MAAIH,MAAM,IAAI,CAAd,EAAiB;AACbG,IAAAA,sBAAsB,GAAGF,SAAS,CAAC,CAAD,CAAlC;AACH;;AACD,MAAIG,aAAa,GAAGC,MAAM,CAACC,iBAA3B;;AACA,MAAIN,MAAM,IAAI,CAAd,EAAiB;AACbI,IAAAA,aAAa,GAAGH,SAAS,CAAC,CAAD,CAAzB;AACH;;AACD,SAAOP,WAAW,CAACI,UAAZ,CAAuBC,cAAvB,EAAuCI,sBAAvC,EAA+DC,aAA/D,EAA8EP,SAA9E,EAAyF,IAAzF,CAAP;AACH;;AACDvD,kBAAA,GAAqBwD,UAArB;;;;;;;;;;;AClEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,0BAA0B;AACrC;AACA,WAAW,2CAA2C;AACtD;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;;AC5CP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,wBAAwB;AACnC;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;ACvCL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;ACjED;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,UAAU;AACrB;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;AC9CL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iBAAM;AAC3B,+BAA+B,mBAAO,CAAC,wCAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,UAAU;AACrB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AChER;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,WAAW;AACtB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;AC5DD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACtDJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,qDAAqD;AAChE;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACzDJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;ACtDN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,+DAA+D;AAC1E;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACtDA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,2CAA2C;AACtD;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;AChDH;;AACb1D,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS8D,YAAT,CAAsBC,OAAtB,EAA+BX,SAA/B,EAA0C;AACtC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACa,YAAZ,CAAyBC,OAAzB,EAAkCX,SAAlC,EAA6C,IAA7C,CAAP;AACH;;AACDvD,oBAAA,GAAuBiE,YAAvB;;;;;;;;;;;ACtDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,KAAK;AAChB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,sBAAsB;;;;;;;;;;;;ACtCT;;AACbnE,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgE,KAAT,CAAeA,KAAf,EAAsBZ,SAAtB,EAAiC;AAC7B,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACe,KAAZ,CAAkBA,KAAlB,EAAyBZ,SAAzB,EAAoC,IAApC,CAAP;AACH;;AACDvD,aAAA,GAAgBmE,KAAhB;;;;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACnDJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA,mCAAmC,oBAAoB;AACvD,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AC9CR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;ACnDH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,UAAU;AACrB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;;AC9Cf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB;AAC9B,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;;ACjElB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,mBAAmB;AAC9B;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;AClDE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,GAAG;AACd,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AChDJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,WAAW,UAAU;AACrB,WAAW,KAAK;AAChB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACpBA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;ACvCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,qDAAqD;AAChE;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;ACzCL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,WAAW;AACtB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,gCAAgC;AAChC;AACA;AACA;AACA,cAAc;;;;;;;;;;;;ACvDD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;AC9CD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,UAAU;AACrB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;AC5EH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,mEAAmE;AAC9E;AACA,WAAW,KAAK;AAChB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;ACxCC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,mEAAmE;AAC9E;AACA,WAAW,KAAK;AAChB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACxCJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,YAAY;AACxB;AACA;AACA,WAAW,mEAAmE;AAC9E;AACA,WAAW,GAAG;AACd;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACtDA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,IAAI,yBAAyB;AAC7B;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,mBAAmB;AAC1C,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,sBAAsB;AAC7C,uBAAuB,oBAAoB;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B;AACA,UAAU,oBAAoB;AAC9B,UAAU,oBAAoB;AAC9B,UAAU,uBAAuB;AACjC,UAAU,0BAA0B;AACpC;AACA,UAAU,sBAAsB;AAChC;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,mBAAmB;AAC1C,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,sBAAsB;AAC7C,uBAAuB,oBAAoB;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR;AACA,WAAW,uBAAuB;AAClC;AACA,WAAW,uBAAuB;AAClC;AACA,WAAW,4DAA4D;AACvE;AACA;AACA,YAAY,oCAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;AC1EF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;;AChBT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;ACfF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,WAAW,UAAU;AACrB,WAAW,KAAK;AAChB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;AC9BC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;ACXH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,sCAAsC;AACjD;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;ACvCE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,KAAK;AAChB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;AChCA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,YAAY,6BAA6B;AACzC,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AClDN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,0BAA0B,oBAAoB;AAC9C,0BAA0B,qBAAqB;AAC/C;AACA,6DAA6D;AAC7D;AACA;AACA,SAAS;AACT;AACA,WAAW,UAAU;AACrB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;ACrCE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,WAAW;AACtB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACzDA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gBAAgB;;;;;;;;;;;;ACnDH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,qDAAqD;AAChE;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gBAAgB;;;;;;;;;;;;ACzDH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,kBAAkB;;;;;;;;;;;;ACzCL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAA2C;AACtD;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,iBAAiB;;;;;;;;;;;;ACtCJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,0BAA0B,oBAAoB;AAC9C,0BAA0B,qBAAqB;AAC/C;AACA,6DAA6D;AAC7D;AACA;AACA,SAAS;AACT;AACA,WAAW,UAAU;AACrB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;ACrCE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,4BAA4B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,cAAc;AACnG,IAAI,mBAAmB,GAAG,sBAAsB,MAAM,qBAAqB,cAAc,cAAc;AACvG,IAAI,kBAAkB,GAAG,uBAAuB,IAAI,qBAAqB;AACzE;AACA;AACA,qBAAqB,eAAe,IAAI,qBAAqB;AAC7D,uBAAuB,aAAa,KAAK,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,YAAY,wCAAwC;AACpD,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACrGJ;;AACbrE,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAImD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiE,SAAT,CAAmBb,SAAnB,EAA8BY,KAA9B,EAAqC;AACjC,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACpC,SAAOf,WAAW,CAACgB,SAAZ,CAAsBb,SAAtB,EAAiCY,KAAjC,EAAwC,IAAxC,CAAP;AACH;;AACDnE,iBAAA,GAAoBoE,SAApB;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E,0FAA0F,aAAa;AACvG;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,oBAAoB;AAC/B,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;;ACxEZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;ACzCH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AC/CJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,WAAW;AACtB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACpCA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;ACpBF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;;ACZV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;ACZN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AChBR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;ACnBC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,sBAAsB,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,8CAA8C;AACzD;AACA,WAAW,GAAG;AACd,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;AC3DD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,cAAc;;;;;;;;;;;;ACnBD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;;ACpBL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,aAAa;;;;;;;;;;;;ACvBA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACpBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;ACxCD;;AACbtE,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkE,UAAT,CAAoBC,MAApB,EAA4Bf,SAA5B,EAAuC;AACnC,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACiB,UAAZ,CAAuBC,MAAvB,EAA+Bf,SAA/B,EAA0C,IAA1C,CAAP;AACH;;AACDvD,kBAAA,GAAqBqE,UAArB;;;;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,8CAA8C;AACzD;AACA,WAAW,KAAK;AAChB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;AC/CC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,YAAY;AACvB,WAAW,UAAU;AACrB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;AC1DR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;;ACtBA;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;ACTN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,WAAW,UAAU;AACrB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;ACtBD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;ACjBC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,yBAAyB;AACrC;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;ACtCH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AClBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AClBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,WAAW,iBAAiB,kBAAkB;AACzD;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACzBJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,mBAAmB;;;;;;;;;;;;AClBN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;AChDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,qDAAqD;AAChE;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AC7CJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,iBAAiB;AAC5B;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;ACzCN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,yBAAyB;AACrC;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;;ACvCC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,YAAY,yBAAyB;AACrC;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;;AC1CH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,YAAY;AACvB;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACxCJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,4CAA4C;AACvD;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;AC1CJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,2BAAgB;AAC1C,+BAA+B,mBAAO,CAAC,wCAA6B;AACpE;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,2CAA2C;AACtD;AACA;AACA,WAAW,QAAQ;AACnB,SAAS,gCAAgC;AACzC,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gBAAgB;;;;;;;;;;;;AChDH;;AACbvE,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIG,wBAAwB,GAAGH,mBAAO,CAAC,wCAAD,CAAtC;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoE,YAAT,CAAsBjB,QAAtB,EAAgCC,SAAhC,EAA2C9C,MAA3C,EAAmD;AAC/C,MAAI8C,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,MAAItC,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAGH,wBAAwB,CAACkE,qBAAlC;AAA0D;;AACnF,SAAOpB,WAAW,CAACmB,YAAZ,CAAyBjB,QAAzB,EAAmCC,SAAnC,EAA8C9C,MAA9C,EAAsD,IAAtD,CAAP;AACH;;AACDT,oBAAA,GAAuBuE,YAAvB;;;;;;;;;;;ACjDa;;AACbzE,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsE,YAAT,CAAsBlB,SAAtB,EAAiC;AAC7B,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACqB,YAAZ,CAAyBlB,SAAzB,EAAoC,IAApC,CAAP;AACH;;AACDvD,oBAAA,GAAuByE,YAAvB;;;;;;;;;;;ACda;;AACb3E,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASuE,OAAT,CAAiBC,GAAjB,EAAsBpB,SAAtB,EAAiC;AAC7B,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,IAAAA,SAAS,GAAGrD,MAAM,CAAC6C,cAAnB;AAAoC;;AAChE,SAAOK,WAAW,CAACsB,OAAZ,CAAoBC,GAApB,EAAyBpB,SAAzB,EAAoC,IAApC,CAAP;AACH;;AACDvD,eAAA,GAAkB0E,OAAlB;;;;;;;;;;;ACzEa;;AACb5E,8CAA6C;AAAEG,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,MAAM,GAAGC,mBAAO,CAAC,iBAAD,CAApB;;AACA,IAAIiD,WAAW,GAAGjD,mBAAO,CAAC,2BAAD,CAAzB;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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R;AACd;AACM;AACQ;AACN;AACd;AACF;AACA;AACM;AACR;AACU;AACc;AAChB;AACV;AACU;AACN;AACA;AACN;AAC8B;AACxB;AACQ;AACV;AACE;AACU;AACV;AACA;AACJ;AACW;AACP;AACA;AACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDC;AACkB;AACA;AACZ;AACK;AACe;AAClB;AACa;AACE;AACZ;AACU;AACqI;AACvH;AACF;AACrB;AAC6B;AACzB;AACM;AACA;AACK;AACR;AACR;AACI;AACwB;AAC1B;AACF;AAC4B;AACtB;AACc;AAChB;AACA;AACQ;AACd;AACF;AACQ;AACV;AACQ;AACA;AACF;AACF;AACsC;AACpC;AACI;AACd;AACF;AACE;AACA;AACc;AACU;AACM;AACI;AACN;AACF;AACV;AACR;;;;;;;;;;;;;;;;;;ACtDjB;AACU;AACvC,2BAA2B,6CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAkB;AACrC;AACA;AACA;AACA;AACA,mBAAmB,6DAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvC2C;AACN;AACgB;AAC9C;AACP;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAE;AACzB;AACA,uBAAuB,kEAAU;AACjC;AACA,uBAAuB,wDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvEoC;AACM;AACI;AACc;AACa;AACb;AACrD,4BAA4B,6CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAuB;AAC7C;AACA;AACA,2BAA2B,6DAAkB;AAC7C;AACA;AACA;AACA,+BAA+B,qEAAmB;AAClD;AACA;AACA,4CAA4C,qEAAmB;AAC/D;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1GO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACT2C;AACF;AACK;AACvC,oCAAoC,mDAAU;AACrD,mDAAmD,iDAAI;AACvD;AACA;AACA;AACA;AACA,aAAa,0DAAS;AACtB;AACA;AACA;AACA,6BAA6B,iDAAI;AACjC;AACA;AACA,iDAAiD,iDAAI;AACrD;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;AC/B2C;AACI;AACR;AACiB;AACd;AACQ;AAC3C;AACP;AACA,YAAY,8DAAW;AACvB;AACA;AACA;AACA,oFAAoF,mDAAG,WAAW,sDAAO;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA,kCAAkC,uDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,YAAY,mCAAmC;AAC/C,UAAU,UAAU;AACpB;AACA,uCAAuC,uDAAY;AACnD;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;;;;;;;;;;;;;;;;;;;;;;ACnF2C;AACI;AACR;AACiB;AACN;AACR;AACnC;AACP;AACA,YAAY,8DAAW;AACvB;AACA;AACA;AACA,wFAAwF,mDAAG,SAAS,sDAAO;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B,oBAAoB,UAAU;AAC9B,kBAAkB,UAAU;AAC5B;AACA;AACA,mDAAmD,uDAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C,YAAY,gCAAgC;AAC5C;AACA;AACA,uCAAuC,uDAAY;AACnD;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FuC;AACO;AACA;AACJ;AAC1C;AACA,QAAQ,2DAAmB;AAC3B,mBAAmB,2DAAmB;AACtC;AACA,eAAe,2DAAmB;AAClC,mBAAmB,2DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAmB;AAC3B,mBAAmB,2DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gCAAgC,6BAA6B;AAC7D;AACO;AACP,gCAAgC,oCAAoC;AACpE;AACO;AACP,gCAAgC,gCAAgC;AAChE;AACO;AACP,gCAAgC,mCAAmC;AACnE;AACO;AACP,gCAAgC,qCAAqC;AACrE;AACA,oBAAoB,mDAAG;AAChB;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAa,4BAA4B,qDAAa;AAC1F,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,sDAAsD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAa,oBAAoB,qDAAa;AAC/D;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB,GAAG,8BAA8B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA,oBAAoB,2DAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAA0C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;ACrWmD;AACZ;AACA;AACI;AACE;AACpD;AACA;AACA;AACA;AACA;AACA,kJAAkJ,8BAA8B;AACzK,+BAA+B,sDAAgB;AACtD;AACA;AACA,yCAAyC,mDAAU;AACnD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,+BAA+B,6CAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,+BAA+B,0DAAiB;AAChD;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,0CAA0C,yDAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/MkD;AAC3C,oBAAoB,kEAAqB;;;;;;;;;;;;;;;;;ACDM;AAC/C;AACP,eAAe,+DAAgB;AAC/B;;;;;;;;;;;;;;;;;;;;ACH2C;AACD;AACM;AACT;AACvC;AACO;AACP,QAAQ,4DAAU;AAClB;AACA;AACA;AACA;AACA,0DAA0D,mDAAG,SAAS,sDAAO;AAC7E;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5D2C;AACD;AACM;AACT;AAChC;AACP;AACA,gEAAgE,mDAAG,SAAS,sDAAO;AACnF;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAU;AACvB;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACvB2C;AACuB;AACD;AAC1D;AACP;AACA;AACA;AACA;AACA,mBAAmB,mDAAU,CAAC,8EAAmB;AACjD;AACA;AACA,eAAe,6EAAgB;AAC/B;AACA;;;;;;;;;;;;;;;;;;;ACb2C;AACqB;AACD;AACxD;AACP;AACA,mBAAmB,mDAAU,CAAC,4EAAkB;AAChD;AACA;AACA,eAAe,2EAAe;AAC9B;AACA;;;;;;;;;;;;;;;;;;;ACV2C;AACC;AACM;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oDAAQ;AAC3D;AACA;AACA,yDAAyD,8DAAW;AACpE;AACA,yBAAyB,oDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,KAAK;AACL;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1HgC;AACA;AACzB,qCAAqC,yCAAK,gBAAgB,yCAAK;AACtE,WAAW,6CAAK;AAChB;;;;;;;;;;;;;;;;;;;ACJ2C;AACA;AACG;AACvC,0CAA0C,mDAAK;AACtD,SAAS,0DAAS;AAClB;AACA;AACA;AACA,oBAAoB,mDAAK;AACzB;AACA,eAAe,mDAAU;AACzB,8DAA8D,gCAAgC;AAC9F;AACA,KAAK;AACL;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA,oBAAoB,0CAA0C;AAC9D;;;;;;;;;;;;;;;;;;;ACnB2C;AACP;AAC7B,kBAAkB,mDAAU,CAAC,4CAAI;AACjC;AACP;AACA;;;;;;;;;;;;;;;;;;;;ACL2C;AACb;AACY;AACV;AACzB;AACP;AACA,eAAe,yCAAK;AACpB;AACA;AACA,gCAAgC,sDAAO;AACvC;AACA;AACA,eAAe,mDAAU;AACzB;AACA,eAAe,2CAAI;AACnB,0BAA0B,yBAAyB;AACnD;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACpB2C;AACI;AACxC;AACP;AACA,mBAAmB,mDAAU;AAC7B;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,mDAAU;AAC7B;AACA,qCAAqC,uDAAY;AACjD,+DAA+D,+CAA+C;AAC9G;AACA,SAAS;AACT;AACA;AACO;AACP,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA,6CAA6C,uDAAuD;AACpG;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpCkC;AACgB;AACL;AACF;AACpC;AACP;AACA,QAAQ,yDAAM,yBAAyB,mDAAU,CAAC,8DAAW;AAC7D,QAAQ,yDAAM,CAAC,8CAAG,0BAA0B,mDAAU,CAAC,8DAAW;AAClE;AACA;;;;;;;;;;;;;;;;;;;;;;ACT0C;AACF;AACa;AACS;AACvD;AACP;AACA,YAAY,sDAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACO;AACP;AACA;AACA;AACA;AACO,6BAA6B,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA,qCAAqC,0EAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9D2C;AACpC;AACP,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,KAAK;AACL;AACO;AACP,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1C2C;AACpC;AACP;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA,mBAAmB,mDAAU,iDAAiD,mBAAmB;AACjG;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;;;;;;;;;;;;;;;;;;;ACX2C;AACA;AACG;AACI;AAC3C;AACP;AACA,QAAQ,0DAAS;AACjB;AACA;AACA,aAAa,8DAAW;AACxB;AACA;AACA,SAAS,8DAAW;AACpB,oBAAoB,mDAAK;AACzB;AACA,eAAe,mDAAU;AACzB,oBAAoB,0DAAS;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnC2C;AACb;AACE;AACzB;AACP,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAI,WAAW,yCAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;AC9BwC;AACE;AACC;AACkC;AACoB;AAC1F;AACP;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO;AACnB;AACA;AACA,8BAA8B,+DAAe;AAC7C,oDAAoD,+DAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAAe;AACpB;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAAe;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAc,sBAAsB,kEAAqB;AACxE;AACA;;;;;;;;;;;;;;;;;ACnMiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAc,eAAe,kEAAqB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5D2C;AACX;AACY;AACrC,yCAAyC,mDAAK;AACrD,WAAW,6CAAK,OAAO,wDAAK;AAC5B;;;;;;;;;;;;;;;;;ACLiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAqB;AACpD;AACA;AACA;AACA,iBAAiB,+DAAc,sBAAsB,kEAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5B2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5E2C;AACA;AACO;AAC3C;AACP;AACA,oBAAoB,mDAAK;AACzB,QAAQ,8DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAgE;AAC5E;AACA;AACA;AACA,uGAAuG,qBAAqB;AAC5H;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;;;;;;;;;;;;;;;;;;;AC3I+C;AACe;AACT;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAe;AACpD;AACA;AACA;AACA;AACA,iBAAiB,0EAAiB;AAClC;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C,0BAA0B;AAC1B;AACA,kCAAkC,0EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClG+C;AACkD;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAY;AAC9C;AACA;AACA;AACA,gCAAgC,+DAAc,sBAAsB,kEAAqB;AACzF;AACA;AACA;;;;;;;;;;;;;;;;;ACzEoE;AAC7D;AACP,uCAAuC,4EAAqB;AAC5D;;;;;;;;;;;;;;;;;;;ACH0C;AAC0B;AAC1B;AAC1C;AACO;AACP;AACA;AACA;AACA;AACA,oCAAoC,sDAAO;AAC3C;AACA;AACA,wCAAwC,sDAAI,gCAAgC,4EAAqB;AACjG;;;;;;;;;;;;;;;;;ACb8D;AACvD;AACP,wCAAwC,0DAAY;AACpD;;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP,WAAW,qDAAS;AACpB;;;;;;;;;;;;;;;;;ACH2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9CiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAc,eAAe,kEAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClE2C;AACA;AACpC,2CAA2C,mDAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrD2C;AACH;AACG;AACI;AACxC,kCAAkC,mDAAK;AAC9C,0BAA0B,oDAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjF2C;AACA;AACU;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0EAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpH2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,kEAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc,cAAc,kEAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvD8D;AACvD;AACP,WAAW,2EAAoB;AAC/B;;;;;;;;;;;;;;;;;;;;;ACH0E;AACxC;AACY;AACI;AACpB;AACvB;AACP;AACA,kBAAkB,kFAAuB;AACzC;AACA;AACA,mCAAmC,+CAAM,yBAAyB,2CAAI;AACtE,UAAU,+DAAc;AACxB,UAAU,2DAAY,WAAW,kFAAuB;AACxD;;;;;;;;;;;;;;;;;;ACb8C;AACR;AAC/B;AACP,uBAAuB,0DAAM,SAAS,kDAAE;AACxC;;;;;;;;;;;;;;;;;ACJ2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc,YAAY,kEAAqB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjC4B;AACc;AACuD;AAC1F;AACP;AACA,4DAA4D,sDAAI,qBAAqB,yCAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA,kCAAkC,+DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvEiG;AAC1F;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,kEAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAc,aAAa,kEAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtF2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,mDAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDsD;AAC/C;AACP,uCAAuC,8DAAiB;AACxD;;;;;;;;;;;;;;;;;;;;;ACH2C;AACI;AACJ;AACN;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,6CAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,mDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClK2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAU;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;ACd2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxB2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpB2C;AACI;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAU;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,kEAAuB;AACrD;AACA;AACA;AACA,yBAAyB,mEAAwB;AACjD;AACA;AACA;AACA;AACA,yBAAyB,sEAA2B;AACpD;AACA;AACA;;;;;;;;;;;;;;;;;AC7BkC;AAC3B;AACP;AACA;AACA;AACA,WAAW,+CAAM;AACjB;;;;;;;;;;;;;;;;;ACN2D;AACpD;AACP,wCAAwC,wDAAW;AACnD;;;;;;;;;;;;;;;;;ACHsC;AAC/B;AACP;AACA,eAAe,mDAAQ;AACvB;AACA;AACA;AACA;AACA,WAAW,mDAAQ;AACnB;;;;;;;;;;;;;;;;;;;ACTiG;AAC1F;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,kEAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA,kCAAkC,+DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnFkC;AAC3B;AACP;AACA;AACA;AACA,WAAW,+CAAM;AACjB;;;;;;;;;;;;;;;;;;;;;ACN2C;AACI;AACxC;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,mDAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAuB;AACpD;AACA;AACA,6BAA6B,mEAAwB;AACrD;AACA;AACA;AACA,6BAA6B,sEAA2B;AACxD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChD0C;AACA;AACuD;AAC1F;AACP,oCAAoC,sDAAO;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,sDAAO;AAC3C;AACA;AACA;AACA,WAAW,sDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAqB;AAC7D;AACA;AACA,sCAAsC,+DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5D2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BkC;AACA;AAC3B;AACP;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM,CAAC,8CAAG;AAClB;AACA;;;;;;;;;;;;;;;;;ACP4B;AACrB;AACP;AACA;AACA;AACA;AACA,uBAAuB,yCAAG;AAC1B;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvBqC;AACG;AACjC;AACP;AACA,QAAQ,qDAAS,WAAW,6CAAO;AACnC,QAAQ,qDAAS,KAAK,6CAAO;AAC7B;;;;;;;;;;;;;;;;;;ACNqD;AACb;AACjC;AACP,uBAAuB,qDAAS,KAAK,6DAAe;AACpD;;;;;;;;;;;;;;;;;;ACJ+C;AACP;AACjC;AACP,uBAAuB,qDAAS,KAAK,uDAAY;AACjD;;;;;;;;;;;;;;;;;;ACJiD;AACT;AACjC;AACP;AACA;AACA;AACA;AACA,wBAAwB,yDAAa;AACrC,uBAAuB,qDAAS;AAChC;;;;;;;;;;;;;;;;;;ACT0C;AACc;AACjD;AACP;AACA,wCAAwC,sDAAO;AAC/C;AACA;AACA,gCAAgC,sDAAU;AAC1C;AACA;;;;;;;;;;;;;;;;;;;;ACT8B;AACQ;AACY;AACd;AAC7B;AACP;AACA;AACA,mBAAmB,gDAAI,CAAC,2CAAI,qBAAqB,mDAAQ,KAAK,+DAAc;AAC5E;AACA;AACA;AACA,eAAe,gDAAI,CAAC,2CAAI,6DAA6D,mDAAQ;AAC7F;AACA;;;;;;;;;;;;;;;;;;ACb2C;AACC;AACrC;AACP;AACA;AACA,mBAAmB,wDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1CqC;AAC4D;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAc,cAAc,kEAAqB;AACpF;AACA;;;;;;;;;;;;;;;;;AC1E2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/BqC;AAC4D;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAc,cAAc,kEAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClEiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAc,oBAAoB,kEAAqB;AAChF;AACA;AACA;AACA,+BAA+B,kEAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpC2C;AACA;AACpC,wCAAwC,mDAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA,oEAAoE,0BAA0B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrC2C;AACpC;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,mDAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mDAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjGiD;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iHAAiH;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa;AACvC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AC7D2C;AACK;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAU;AAC5C;AACA;AACA;;;;;;;;;;;;;;;;;AC5D2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvB2C;AAC+B;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAuB;AAC7C;AACA;AACA;AACA;AACA,wCAAwC,mDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1CiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA,kCAAkC,+DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtC2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrC4E;AACrE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oFAAqB;AACxC;AACA;;;;;;;;;;;;;;;;;;ACdwC;AACI;AACrC;AACP,WAAW,qDAAS,CAAC,oDAAQ;AAC7B;;;;;;;;;;;;;;;;;ACJwC;AACjC;AACP,4BAA4B,qDAAS,0CAA0C,qDAAS;AACxF;;;;;;;;;;;;;;;;;ACHiG;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAc,oBAAoB,kEAAqB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7B2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CiG;AAC1F;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+DAAc,eAAe,kEAAqB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/E2C;AACA;AACQ;AAC5C,4CAA4C,mDAAK,WAAW,4DAAqB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,kBAAkB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;;;;;;;;;;;;;;;;;;;;;ACvE2C;AACb;AACc;AAChB;AACrB,kCAAkC,mDAAK;AAC9C,uBAAuB,wDAAK;AAC5B,2BAA2B,2CAAI,IAAI,SAAS,eAAe,gDAAgD,KAAK,6DAA6D,GAAG,yCAAG,IAAI,sBAAsB;AAC7M,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACd2C;AACS;AACR;AACU;AAC/C,kCAAkC,mDAAK;AAC9C,WAAW,yDAAW,MAAM,kEAAU,KAAK,4DAAY;AACvD;;;;;;;;;;;;;;;;;;;ACN2C;AACH;AACyD;AAC1F,sDAAsD,mDAAK;AAClE;AACA,8BAA8B,oDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA,uBAAuB,+DAAc,qBAAqB,kEAAqB;AAC/E;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvD2C;AACf;AACrB,+BAA+B,mDAAK;AAC3C,WAAW,yCAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,+CAAM;AACjB;;;;;;;;;;;;;;;;;;ACVqC;AAC4D;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAc,4BAA4B,kEAAqB;AAChG;AACA;AACA;AACA;AACA,+BAA+B,kEAAqB;AACpD;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6CAAO;AACnD;AACA;AACA;;;;;;;;;;;;;;;;;;AC1D2C;AACN;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnEqC;AACM;AACA;AACG;AACI;AAC3C;AACP,oBAAoB,mDAAK;AACzB;AACA;AACA,QAAQ,8DAAW;AACnB;AACA;AACA,QAAQ,8DAAW;AACnB;AACA;AACA,aAAa,0DAAS;AACtB;AACA;AACA,QAAQ,8DAAW;AACnB;AACA;AACA,aAAa,0DAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAgE;AAC5E;AACA;AACA,oBAAoB;AACpB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5IqC;AACU;AACM;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAe;AACpD;AACA;AACA;AACA;AACA;AACA,yCAAyC,0EAAiB;AAC1D;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAO;AACtC,qCAAqC,uDAAY;AACjD,8BAA8B;AAC9B;AACA,sCAAsC,0EAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzHqC;AACgB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6CAAO;AAChD;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0EAAiB;AAC7D;AACA;;;;;;;;;;;;;;;;;;ACzEqD;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,wBAAwB,SAAS;AACjC;AACA,qBAAqB,0EAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvEqD;AAC9C;AACP;AACA,gCAAgC,oDAAS;AACzC;AACA;;;;;;;;;;;;;;;;;ACLgD;AACzC;AACP,uCAAuC,wDAAW;AAClD;;;;;;;;;;;;;;;;;ACH+C;AACxC,qBAAqB,uDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACR4C;AACrC,mCAAmC,qDAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxBkD;AAC3C,sCAAsC,2DAAc;AAC3D;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvB8C;AACF;AACrC,yBAAyB,qDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mEAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAwB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBkD;AAC3C,4BAA4B,2DAAc;AACjD;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvBkC;AAC3B,0BAA0B,2CAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9EyC;AAClC,6BAA6B,iDAAS;AAC7C,uCAAuC,qDAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5C4C;AACrC,0BAA0B,qDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BkD;AAC3C,6BAA6B,2DAAc;AAClD;;;;;;;;;;;;;;;;;;;ACF4C;AACM;AAC3C,mCAAmC,2DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,qDAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChF8D;AACM;AAC7D,oCAAoC,6EAAuB,CAAC,uEAAoB;AAChF;;;;;;;;;;;;;;;;;;;ACHmC;AACM;AACzC,0BAA0B,yDAAa,CAAC,mDAAU;AAClD;;;;;;;;;;;;;;;;;;;ACHqC;AACM;AAC3C,2BAA2B,2DAAc,CAAC,qDAAW;AACrD;;;;;;;;;;;;;;;;;;;ACHqC;AACM;AAC3C,2BAA2B,2DAAc,CAAC,qDAAW;AACrD;;;;;;;;;;;;;;;;;;;;ACHoC;AACI;AACe;AACZ;AAC3C,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA,qCAAqC,uDAAY;AACjD,iCAAiC,uDAAY;AAC7C;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,sDAAsD,qBAAqB,OAAO,2CAA2C,mBAAmB,qBAAqB;AACrK;AACA;AACA;AACA,8DAAW,kBAAkB,uEAAoB;;;;;;;;;;;;;;;;;;;;AC5BZ;AACU;AACe;AACZ;AAC3C,4BAA4B,6CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C,6BAA6B,uDAAY;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,mDAAmD,wCAAwC;AAC3F,aAAa;AACb;AACA;AACA;AACA,8DAAW,iBAAiB,uEAAoB;;;;;;;;;;;;;;;;AChCzC;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACLoD;AAC7C;AACP;AACA;AACA;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAe;AACrD;AACA;;;;;;;;;;;;;;;;;;;;;;;ACd2C;AACI;AACG;AACF;AACI;AACoC;AAC3B;AAC7D;AACO,4BAA4B,iFAAoB;AACvD;AACA,cAAc,0EAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAA8C,kEAAuB,SAAS;AAC1G,SAAS;AACT,4BAA4B,8CAA8C,mEAAwB,OAAO;AACzG,SAAS;AACT,4BAA4B,8CAA8C,sEAA2B,IAAI;AACzG,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAU;AAC3C;AACA;AACA,8BAA8B,iCAAiC,kEAAuB,SAAS;AAC/F,aAAa;AACb,8BAA8B,iCAAiC,mEAAwB,OAAO;AAC9F,aAAa;AACb,8BAA8B,iCAAiC,sEAA2B,IAAI;AAC9F,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,6DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAe;AACtC;AACA;AACA,uBAAuB,6DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,2DAAc;AACtF;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAuB;AAC1D;AACA;AACA;AACA;AACA,oCAAoC,2DAA2D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAAuB;AACnC;AACA;AACA;;;;;;;;;;;;;;;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;;;;;;;;;;;;;;;;ACVA;AACP,4CAA4C,SAAS;AACrD;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTO,sBAAsB;;;;;;;;;;;;;;;;ACAtB;AACP;AACA;;;;;;;;;;;;;;;;;ACFoC;AAC7B;AACP,YAAY,iDAAO;AACnB;;;;;;;;;;;;;;;;;ACH2C;AACpC;AACP,oCAAoC,mDAAU;AAC9C;;;;;;;;;;;;;;;;ACHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;;;;;;;;;;;;;;;;;ACVmB;AAC5C;AACA;AACA,IAAI,uDAAa;AACjB;AACA;AACA;AACA;AACA,QAAQ,uDAAa;AACrB,eAAe,qDAAW;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBoD;AACQ;AACN;AACU;AACF;AACI;AACJ;AACA;AACA;AACM;AACd;AACM;AACA;AACI;AACZ;AACM;AACQ;AACI;AAClB;AACQ;AACQ;AACV;AACwB;AACM;AAC5B;AACJ;AACJ;AACI;AACM;AACR;AACA;AACI;AACR;AACU;AACR;AACI;AACc;AACd;AACN;AACF;AACI;AACY;AAChB;AACI;AACM;AACS;AACL;AACF;AACZ;AACY;AACA;AACgB;AAClB;AACE;AACR;AACI;AACgB;AACR;AACI;AAClB;AACI;AACA;AACQ;AACV;AACQ;AACF;AACJ;AACQ;AACZ;AACkB;AAChB;AACY;AACV;AACJ;AACQ;AACE;AACA;AACA;AACI;AACJ;AACA;AACI;AACd;AACQ;AACE;AACA;AACZ;AACU;AACQ;AACA;AACA;AACV;AACQ;AACJ;AACJ;AACF;AACU;AACF;AACI;AACJ;AACQ;AACtB;AACM;;;;;;;;;;;;;;;;;ACtGY;;;;;;;;;;;;;;;;;;;ACAY;AACC","sources":["./src/app/cache.service.ts","./node_modules/rxjs-compat/Observable.js","./node_modules/rxjs-compat/Rx.js","./node_modules/rxjs-compat/add/observable/bindCallback.js","./node_modules/rxjs-compat/add/observable/bindNodeCallback.js","./node_modules/rxjs-compat/add/observable/combineLatest.js","./node_modules/rxjs-compat/add/observable/concat.js","./node_modules/rxjs-compat/add/observable/defer.js","./node_modules/rxjs-compat/add/observable/dom/ajax.js","./node_modules/rxjs-compat/add/observable/dom/webSocket.js","./node_modules/rxjs-compat/add/observable/empty.js","./node_modules/rxjs-compat/add/observable/forkJoin.js","./node_modules/rxjs-compat/add/observable/from.js","./node_modules/rxjs-compat/add/observable/fromEvent.js","./node_modules/rxjs-compat/add/observable/fromEventPattern.js","./node_modules/rxjs-compat/add/observable/fromPromise.js","./node_modules/rxjs-compat/add/observable/generate.js","./node_modules/rxjs-compat/add/observable/if.js","./node_modules/rxjs-compat/add/observable/interval.js","./node_modules/rxjs-compat/add/observable/merge.js","./node_modules/rxjs-compat/add/observable/never.js","./node_modules/rxjs-compat/add/observable/of.js","./node_modules/rxjs-compat/add/observable/onErrorResumeNext.js","./node_modules/rxjs-compat/add/observable/pairs.js","./node_modules/rxjs-compat/add/observable/race.js","./node_modules/rxjs-compat/add/observable/range.js","./node_modules/rxjs-compat/add/observable/throw.js","./node_modules/rxjs-compat/add/observable/timer.js","./node_modules/rxjs-compat/add/observable/using.js","./node_modules/rxjs-compat/add/observable/zip.js","./node_modules/rxjs-compat/add/operator/audit.js","./node_modules/rxjs-compat/add/operator/auditTime.js","./node_modules/rxjs-compat/add/operator/buffer.js","./node_modules/rxjs-compat/add/operator/bufferCount.js","./node_modules/rxjs-compat/add/operator/bufferTime.js","./node_modules/rxjs-compat/add/operator/bufferToggle.js","./node_modules/rxjs-compat/add/operator/bufferWhen.js","./node_modules/rxjs-compat/add/operator/catch.js","./node_modules/rxjs-compat/add/operator/combineAll.js","./node_modules/rxjs-compat/add/operator/combineLatest.js","./node_modules/rxjs-compat/add/operator/concat.js","./node_modules/rxjs-compat/add/operator/concatAll.js","./node_modules/rxjs-compat/add/operator/concatMap.js","./node_modules/rxjs-compat/add/operator/concatMapTo.js","./node_modules/rxjs-compat/add/operator/count.js","./node_modules/rxjs-compat/add/operator/debounce.js","./node_modules/rxjs-compat/add/operator/debounceTime.js","./node_modules/rxjs-compat/add/operator/defaultIfEmpty.js","./node_modules/rxjs-compat/add/operator/delay.js","./node_modules/rxjs-compat/add/operator/delayWhen.js","./node_modules/rxjs-compat/add/operator/dematerialize.js","./node_modules/rxjs-compat/add/operator/distinct.js","./node_modules/rxjs-compat/add/operator/distinctUntilChanged.js","./node_modules/rxjs-compat/add/operator/distinctUntilKeyChanged.js","./node_modules/rxjs-compat/add/operator/do.js","./node_modules/rxjs-compat/add/operator/elementAt.js","./node_modules/rxjs-compat/add/operator/every.js","./node_modules/rxjs-compat/add/operator/exhaust.js","./node_modules/rxjs-compat/add/operator/exhaustMap.js","./node_modules/rxjs-compat/add/operator/expand.js","./node_modules/rxjs-compat/add/operator/filter.js","./node_modules/rxjs-compat/add/operator/finally.js","./node_modules/rxjs-compat/add/operator/find.js","./node_modules/rxjs-compat/add/operator/findIndex.js","./node_modules/rxjs-compat/add/operator/first.js","./node_modules/rxjs-compat/add/operator/groupBy.js","./node_modules/rxjs-compat/add/operator/ignoreElements.js","./node_modules/rxjs-compat/add/operator/isEmpty.js","./node_modules/rxjs-compat/add/operator/last.js","./node_modules/rxjs-compat/add/operator/let.js","./node_modules/rxjs-compat/add/operator/map.js","./node_modules/rxjs-compat/add/operator/mapTo.js","./node_modules/rxjs-compat/add/operator/materialize.js","./node_modules/rxjs-compat/add/operator/max.js","./node_modules/rxjs-compat/add/operator/merge.js","./node_modules/rxjs-compat/add/operator/mergeAll.js","./node_modules/rxjs-compat/add/operator/mergeMap.js","./node_modules/rxjs-compat/add/operator/mergeMapTo.js","./node_modules/rxjs-compat/add/operator/mergeScan.js","./node_modules/rxjs-compat/add/operator/min.js","./node_modules/rxjs-compat/add/operator/multicast.js","./node_modules/rxjs-compat/add/operator/observeOn.js","./node_modules/rxjs-compat/add/operator/onErrorResumeNext.js","./node_modules/rxjs-compat/add/operator/pairwise.js","./node_modules/rxjs-compat/add/operator/partition.js","./node_modules/rxjs-compat/add/operator/pluck.js","./node_modules/rxjs-compat/add/operator/publish.js","./node_modules/rxjs-compat/add/operator/publishBehavior.js","./node_modules/rxjs-compat/add/operator/publishLast.js","./node_modules/rxjs-compat/add/operator/publishReplay.js","./node_modules/rxjs-compat/add/operator/race.js","./node_modules/rxjs-compat/add/operator/reduce.js","./node_modules/rxjs-compat/add/operator/repeat.js","./node_modules/rxjs-compat/add/operator/repeatWhen.js","./node_modules/rxjs-compat/add/operator/retry.js","./node_modules/rxjs-compat/add/operator/retryWhen.js","./node_modules/rxjs-compat/add/operator/sample.js","./node_modules/rxjs-compat/add/operator/sampleTime.js","./node_modules/rxjs-compat/add/operator/scan.js","./node_modules/rxjs-compat/add/operator/sequenceEqual.js","./node_modules/rxjs-compat/add/operator/share.js","./node_modules/rxjs-compat/add/operator/shareReplay.js","./node_modules/rxjs-compat/add/operator/single.js","./node_modules/rxjs-compat/add/operator/skip.js","./node_modules/rxjs-compat/add/operator/skipLast.js","./node_modules/rxjs-compat/add/operator/skipUntil.js","./node_modules/rxjs-compat/add/operator/skipWhile.js","./node_modules/rxjs-compat/add/operator/startWith.js","./node_modules/rxjs-compat/add/operator/subscribeOn.js","./node_modules/rxjs-compat/add/operator/switch.js","./node_modules/rxjs-compat/add/operator/switchMap.js","./node_modules/rxjs-compat/add/operator/switchMapTo.js","./node_modules/rxjs-compat/add/operator/take.js","./node_modules/rxjs-compat/add/operator/takeLast.js","./node_modules/rxjs-compat/add/operator/takeUntil.js","./node_modules/rxjs-compat/add/operator/takeWhile.js","./node_modules/rxjs-compat/add/operator/throttle.js","./node_modules/rxjs-compat/add/operator/throttleTime.js","./node_modules/rxjs-compat/add/operator/timeInterval.js","./node_modules/rxjs-compat/add/operator/timeout.js","./node_modules/rxjs-compat/add/operator/timeoutWith.js","./node_modules/rxjs-compat/add/operator/timestamp.js","./node_modules/rxjs-compat/add/operator/toArray.js","./node_modules/rxjs-compat/add/operator/toPromise.js","./node_modules/rxjs-compat/add/operator/window.js","./node_modules/rxjs-compat/add/operator/windowCount.js","./node_modules/rxjs-compat/add/operator/windowTime.js","./node_modules/rxjs-compat/add/operator/windowToggle.js","./node_modules/rxjs-compat/add/operator/windowWhen.js","./node_modules/rxjs-compat/add/operator/withLatestFrom.js","./node_modules/rxjs-compat/add/operator/zip.js","./node_modules/rxjs-compat/add/operator/zipAll.js","./node_modules/rxjs-compat/operator/audit.js","./node_modules/rxjs-compat/operator/auditTime.js","./node_modules/rxjs-compat/operator/buffer.js","./node_modules/rxjs-compat/operator/bufferCount.js","./node_modules/rxjs-compat/operator/bufferTime.js","./node_modules/rxjs-compat/operator/bufferToggle.js","./node_modules/rxjs-compat/operator/bufferWhen.js","./node_modules/rxjs-compat/operator/catch.js","./node_modules/rxjs-compat/operator/combineAll.js","./node_modules/rxjs-compat/operator/combineLatest.js","./node_modules/rxjs-compat/operator/concat.js","./node_modules/rxjs-compat/operator/concatAll.js","./node_modules/rxjs-compat/operator/concatMap.js","./node_modules/rxjs-compat/operator/concatMapTo.js","./node_modules/rxjs-compat/operator/count.js","./node_modules/rxjs-compat/operator/debounce.js","./node_modules/rxjs-compat/operator/debounceTime.js","./node_modules/rxjs-compat/operator/defaultIfEmpty.js","./node_modules/rxjs-compat/operator/delay.js","./node_modules/rxjs-compat/operator/delayWhen.js","./node_modules/rxjs-compat/operator/dematerialize.js","./node_modules/rxjs-compat/operator/distinct.js","./node_modules/rxjs-compat/operator/distinctUntilChanged.js","./node_modules/rxjs-compat/operator/distinctUntilKeyChanged.js","./node_modules/rxjs-compat/operator/do.js","./node_modules/rxjs-compat/operator/elementAt.js","./node_modules/rxjs-compat/operator/every.js","./node_modules/rxjs-compat/operator/exhaust.js","./node_modules/rxjs-compat/operator/exhaustMap.js","./node_modules/rxjs-compat/operator/expand.js","./node_modules/rxjs-compat/operator/filter.js","./node_modules/rxjs-compat/operator/finally.js","./node_modules/rxjs-compat/operator/find.js","./node_modules/rxjs-compat/operator/findIndex.js","./node_modules/rxjs-compat/operator/first.js","./node_modules/rxjs-compat/operator/groupBy.js","./node_modules/rxjs-compat/operator/ignoreElements.js","./node_modules/rxjs-compat/operator/isEmpty.js","./node_modules/rxjs-compat/operator/last.js","./node_modules/rxjs-compat/operator/let.js","./node_modules/rxjs-compat/operator/map.js","./node_modules/rxjs-compat/operator/mapTo.js","./node_modules/rxjs-compat/operator/materialize.js","./node_modules/rxjs-compat/operator/max.js","./node_modules/rxjs-compat/operator/merge.js","./node_modules/rxjs-compat/operator/mergeAll.js","./node_modules/rxjs-compat/operator/mergeMap.js","./node_modules/rxjs-compat/operator/mergeMapTo.js","./node_modules/rxjs-compat/operator/mergeScan.js","./node_modules/rxjs-compat/operator/min.js","./node_modules/rxjs-compat/operator/multicast.js","./node_modules/rxjs-compat/operator/observeOn.js","./node_modules/rxjs-compat/operator/onErrorResumeNext.js","./node_modules/rxjs-compat/operator/pairwise.js","./node_modules/rxjs-compat/operator/partition.js","./node_modules/rxjs-compat/operator/pluck.js","./node_modules/rxjs-compat/operator/publish.js","./node_modules/rxjs-compat/operator/publishBehavior.js","./node_modules/rxjs-compat/operator/publishLast.js","./node_modules/rxjs-compat/operator/publishReplay.js","./node_modules/rxjs-compat/operator/race.js","./node_modules/rxjs-compat/operator/reduce.js","./node_modules/rxjs-compat/operator/repeat.js","./node_modules/rxjs-compat/operator/repeatWhen.js","./node_modules/rxjs-compat/operator/retry.js","./node_modules/rxjs-compat/operator/retryWhen.js","./node_modules/rxjs-compat/operator/sample.js","./node_modules/rxjs-compat/operator/sampleTime.js","./node_modules/rxjs-compat/operator/scan.js","./node_modules/rxjs-compat/operator/sequenceEqual.js","./node_modules/rxjs-compat/operator/share.js","./node_modules/rxjs-compat/operator/shareReplay.js","./node_modules/rxjs-compat/operator/single.js","./node_modules/rxjs-compat/operator/skip.js","./node_modules/rxjs-compat/operator/skipLast.js","./node_modules/rxjs-compat/operator/skipUntil.js","./node_modules/rxjs-compat/operator/skipWhile.js","./node_modules/rxjs-compat/operator/startWith.js","./node_modules/rxjs-compat/operator/subscribeOn.js","./node_modules/rxjs-compat/operator/switch.js","./node_modules/rxjs-compat/operator/switchMap.js","./node_modules/rxjs-compat/operator/switchMapTo.js","./node_modules/rxjs-compat/operator/take.js","./node_modules/rxjs-compat/operator/takeLast.js","./node_modules/rxjs-compat/operator/takeUntil.js","./node_modules/rxjs-compat/operator/takeWhile.js","./node_modules/rxjs-compat/operator/throttle.js","./node_modules/rxjs-compat/operator/throttleTime.js","./node_modules/rxjs-compat/operator/timeInterval.js","./node_modules/rxjs-compat/operator/timeout.js","./node_modules/rxjs-compat/operator/timeoutWith.js","./node_modules/rxjs-compat/operator/timestamp.js","./node_modules/rxjs-compat/operator/toArray.js","./node_modules/rxjs-compat/operator/window.js","./node_modules/rxjs-compat/operator/windowCount.js","./node_modules/rxjs-compat/operator/windowTime.js","./node_modules/rxjs-compat/operator/windowToggle.js","./node_modules/rxjs-compat/operator/windowWhen.js","./node_modules/rxjs-compat/operator/withLatestFrom.js","./node_modules/rxjs-compat/operator/zip.js","./node_modules/rxjs-compat/operator/zipAll.js","./node_modules/rxjs/Observable.js","./node_modules/rxjs/Rx.js","./node_modules/rxjs/_esm2015/ajax/index.js","./node_modules/rxjs/_esm2015/index.js","./node_modules/rxjs/_esm2015/internal-compatibility/index.js","./node_modules/rxjs/_esm2015/internal/AsyncSubject.js","./node_modules/rxjs/_esm2015/internal/Notification.js","./node_modules/rxjs/_esm2015/internal/ReplaySubject.js","./node_modules/rxjs/_esm2015/internal/Scheduler.js","./node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js","./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js","./node_modules/rxjs/_esm2015/internal/observable/bindNodeCallback.js","./node_modules/rxjs/_esm2015/internal/observable/dom/AjaxObservable.js","./node_modules/rxjs/_esm2015/internal/observable/dom/WebSocketSubject.js","./node_modules/rxjs/_esm2015/internal/observable/dom/ajax.js","./node_modules/rxjs/_esm2015/internal/observable/dom/webSocket.js","./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js","./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js","./node_modules/rxjs/_esm2015/internal/observable/fromIterable.js","./node_modules/rxjs/_esm2015/internal/observable/fromPromise.js","./node_modules/rxjs/_esm2015/internal/observable/generate.js","./node_modules/rxjs/_esm2015/internal/observable/iif.js","./node_modules/rxjs/_esm2015/internal/observable/interval.js","./node_modules/rxjs/_esm2015/internal/observable/never.js","./node_modules/rxjs/_esm2015/internal/observable/onErrorResumeNext.js","./node_modules/rxjs/_esm2015/internal/observable/pairs.js","./node_modules/rxjs/_esm2015/internal/observable/partition.js","./node_modules/rxjs/_esm2015/internal/observable/race.js","./node_modules/rxjs/_esm2015/internal/observable/range.js","./node_modules/rxjs/_esm2015/internal/observable/throwError.js","./node_modules/rxjs/_esm2015/internal/observable/timer.js","./node_modules/rxjs/_esm2015/internal/observable/using.js","./node_modules/rxjs/_esm2015/internal/observable/zip.js","./node_modules/rxjs/_esm2015/internal/operators/audit.js","./node_modules/rxjs/_esm2015/internal/operators/auditTime.js","./node_modules/rxjs/_esm2015/internal/operators/buffer.js","./node_modules/rxjs/_esm2015/internal/operators/bufferCount.js","./node_modules/rxjs/_esm2015/internal/operators/bufferTime.js","./node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js","./node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js","./node_modules/rxjs/_esm2015/internal/operators/combineAll.js","./node_modules/rxjs/_esm2015/internal/operators/combineLatest.js","./node_modules/rxjs/_esm2015/internal/operators/concat.js","./node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js","./node_modules/rxjs/_esm2015/internal/operators/count.js","./node_modules/rxjs/_esm2015/internal/operators/debounce.js","./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js","./node_modules/rxjs/_esm2015/internal/operators/delay.js","./node_modules/rxjs/_esm2015/internal/operators/delayWhen.js","./node_modules/rxjs/_esm2015/internal/operators/dematerialize.js","./node_modules/rxjs/_esm2015/internal/operators/distinct.js","./node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js","./node_modules/rxjs/_esm2015/internal/operators/elementAt.js","./node_modules/rxjs/_esm2015/internal/operators/endWith.js","./node_modules/rxjs/_esm2015/internal/operators/every.js","./node_modules/rxjs/_esm2015/internal/operators/exhaust.js","./node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js","./node_modules/rxjs/_esm2015/internal/operators/expand.js","./node_modules/rxjs/_esm2015/internal/operators/find.js","./node_modules/rxjs/_esm2015/internal/operators/findIndex.js","./node_modules/rxjs/_esm2015/internal/operators/groupBy.js","./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js","./node_modules/rxjs/_esm2015/internal/operators/isEmpty.js","./node_modules/rxjs/_esm2015/internal/operators/mapTo.js","./node_modules/rxjs/_esm2015/internal/operators/materialize.js","./node_modules/rxjs/_esm2015/internal/operators/max.js","./node_modules/rxjs/_esm2015/internal/operators/merge.js","./node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js","./node_modules/rxjs/_esm2015/internal/operators/mergeScan.js","./node_modules/rxjs/_esm2015/internal/operators/min.js","./node_modules/rxjs/_esm2015/internal/operators/observeOn.js","./node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js","./node_modules/rxjs/_esm2015/internal/operators/pairwise.js","./node_modules/rxjs/_esm2015/internal/operators/partition.js","./node_modules/rxjs/_esm2015/internal/operators/pluck.js","./node_modules/rxjs/_esm2015/internal/operators/publish.js","./node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js","./node_modules/rxjs/_esm2015/internal/operators/publishLast.js","./node_modules/rxjs/_esm2015/internal/operators/publishReplay.js","./node_modules/rxjs/_esm2015/internal/operators/race.js","./node_modules/rxjs/_esm2015/internal/operators/reduce.js","./node_modules/rxjs/_esm2015/internal/operators/repeat.js","./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js","./node_modules/rxjs/_esm2015/internal/operators/retry.js","./node_modules/rxjs/_esm2015/internal/operators/retryWhen.js","./node_modules/rxjs/_esm2015/internal/operators/sample.js","./node_modules/rxjs/_esm2015/internal/operators/sampleTime.js","./node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js","./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js","./node_modules/rxjs/_esm2015/internal/operators/single.js","./node_modules/rxjs/_esm2015/internal/operators/skip.js","./node_modules/rxjs/_esm2015/internal/operators/skipLast.js","./node_modules/rxjs/_esm2015/internal/operators/skipUntil.js","./node_modules/rxjs/_esm2015/internal/operators/skipWhile.js","./node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js","./node_modules/rxjs/_esm2015/internal/operators/switchAll.js","./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js","./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js","./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js","./node_modules/rxjs/_esm2015/internal/operators/throttle.js","./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js","./node_modules/rxjs/_esm2015/internal/operators/timeInterval.js","./node_modules/rxjs/_esm2015/internal/operators/timeout.js","./node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js","./node_modules/rxjs/_esm2015/internal/operators/timestamp.js","./node_modules/rxjs/_esm2015/internal/operators/toArray.js","./node_modules/rxjs/_esm2015/internal/operators/window.js","./node_modules/rxjs/_esm2015/internal/operators/windowCount.js","./node_modules/rxjs/_esm2015/internal/operators/windowTime.js","./node_modules/rxjs/_esm2015/internal/operators/windowToggle.js","./node_modules/rxjs/_esm2015/internal/operators/windowWhen.js","./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js","./node_modules/rxjs/_esm2015/internal/operators/zip.js","./node_modules/rxjs/_esm2015/internal/operators/zipAll.js","./node_modules/rxjs/_esm2015/internal/scheduler/Action.js","./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js","./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/VirtualTimeScheduler.js","./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js","./node_modules/rxjs/_esm2015/internal/scheduler/asap.js","./node_modules/rxjs/_esm2015/internal/scheduler/async.js","./node_modules/rxjs/_esm2015/internal/scheduler/queue.js","./node_modules/rxjs/_esm2015/internal/testing/ColdObservable.js","./node_modules/rxjs/_esm2015/internal/testing/HotObservable.js","./node_modules/rxjs/_esm2015/internal/testing/SubscriptionLog.js","./node_modules/rxjs/_esm2015/internal/testing/SubscriptionLoggable.js","./node_modules/rxjs/_esm2015/internal/testing/TestScheduler.js","./node_modules/rxjs/_esm2015/internal/util/Immediate.js","./node_modules/rxjs/_esm2015/internal/util/TimeoutError.js","./node_modules/rxjs/_esm2015/internal/util/applyMixins.js","./node_modules/rxjs/_esm2015/internal/util/errorObject.js","./node_modules/rxjs/_esm2015/internal/util/isDate.js","./node_modules/rxjs/_esm2015/internal/util/isNumeric.js","./node_modules/rxjs/_esm2015/internal/util/isObservable.js","./node_modules/rxjs/_esm2015/internal/util/not.js","./node_modules/rxjs/_esm2015/internal/util/root.js","./node_modules/rxjs/_esm2015/internal/util/tryCatch.js","./node_modules/rxjs/_esm2015/operators/index.js","./node_modules/rxjs/_esm2015/testing/index.js","./node_modules/rxjs/_esm2015/webSocket/index.js"],"sourcesContent":["// https://hackernoon.com/angular-simple-in-memory-cache-service-on-the-ui-with-rxjs-77f167387e39\n\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Rx';\nimport { throwError } from 'rxjs';\n\ninterface CacheContent {\n  expiry: number;\n  value: any;\n}\n@Injectable({\n  providedIn: 'root'\n})\n/**\n * Cache Service is an observables based in-memory cache implementation\n * Keeps track of in-flight observables and sets a default expiry for cached values\n * @export\n * @class CacheService\n */\nexport class CacheService {\n  private cache: Map<string, CacheContent> = new Map<string, CacheContent>();\n  private inFlightObservables: Map<string, Subject<any>> = new Map<string, Subject<any>>();\n  readonly DEFAULT_MAX_AGE: number = 300000;\n\n  /**\n   * Gets the value from cache if the key is provided.\n   * If no value exists in cache, then check if the same call exists\n   * in flight, if so return the subject. If not create a new\n   * Subject inFlightObservable and return the source observable.\n   */\n  get(key: string, fallback?: Observable<any>, maxAge?: number): Observable<any> | Subject<any> {\n\n    if (this.hasValidCachedValue(key)) {\n      console.log(`%cGetting from cache ${key}`, 'color: green');\n      return Observable.of(this.cache.get(key).value);\n    }\n\n    if (!maxAge) {\n      maxAge = this.DEFAULT_MAX_AGE;\n    }\n\n    if (this.inFlightObservables.has(key)) {\n      return this.inFlightObservables.get(key);\n    } else if (fallback && fallback instanceof Observable) {\n      this.inFlightObservables.set(key, new Subject());\n      console.log(`%c Calling api for ${key}`, 'color: purple');\n      return fallback.do((value) => { this.set(key, value, maxAge); });\n    } else {\n      return throwError('Requested key is not available in Cache');\n    }\n\n  }\n\n  /**\n   * Sets the value with key in the cache\n   * Notifies all observers of the new value\n   */\n  set(key: string, value: any, maxAge: number = this.DEFAULT_MAX_AGE): void {\n    this.cache.set(key, { value, expiry: Date.now() + maxAge });\n    this.notifyInFlightObservers(key, value);\n  }\n\n  /**\n   * Checks if the a key exists in cache\n   */\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Cleans cache\n   */\n  delete(key: string): boolean {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Publishes the value to all observers of the given\n   * in progress observables if observers exist.\n   */\n  private notifyInFlightObservers(key: string, value: any): void {\n    if (this.inFlightObservables.has(key)) {\n      const inFlight = this.inFlightObservables.get(key);\n      const observersCount = inFlight.observers.length;\n      if (observersCount) {\n        console.log(`%cNotifying ${inFlight.observers.length} flight subscribers for ${key}`, 'color: blue');\n        inFlight.next(value);\n      }\n      inFlight.complete();\n      this.inFlightObservables.delete(key);\n    }\n  }\n\n  /**\n   * Checks if the key exists and   has not expired.\n   */\n  private hasValidCachedValue(key: string): boolean {\n    if (this.cache.has(key)) {\n      if (this.cache.get(key).expiry < Date.now()) {\n        this.cache.delete(key);\n        return false;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nexports.Observable = rxjs_1.Observable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable:no-unused-variable */\n// Subject imported before Observable to bypass circular dependency issue since\n// Subject extends Observable and Observable references Subject in it's\n// definition\nvar rxjs_1 = require(\"rxjs\");\nexports.Observable = rxjs_1.Observable;\nexports.Subject = rxjs_1.Subject;\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\nexports.AnonymousSubject = internal_compatibility_1.AnonymousSubject;\n/* tslint:enable:no-unused-variable */\nvar internal_compatibility_2 = require(\"rxjs/internal-compatibility\");\nexports.config = internal_compatibility_2.config;\n// statics\n/* tslint:disable:no-use-before-declare */\nrequire(\"./add/observable/bindCallback\");\nrequire(\"./add/observable/bindNodeCallback\");\nrequire(\"./add/observable/combineLatest\");\nrequire(\"./add/observable/concat\");\nrequire(\"./add/observable/defer\");\nrequire(\"./add/observable/empty\");\nrequire(\"./add/observable/forkJoin\");\nrequire(\"./add/observable/from\");\nrequire(\"./add/observable/fromEvent\");\nrequire(\"./add/observable/fromEventPattern\");\nrequire(\"./add/observable/fromPromise\");\nrequire(\"./add/observable/generate\");\nrequire(\"./add/observable/if\");\nrequire(\"./add/observable/interval\");\nrequire(\"./add/observable/merge\");\nrequire(\"./add/observable/race\");\nrequire(\"./add/observable/never\");\nrequire(\"./add/observable/of\");\nrequire(\"./add/observable/onErrorResumeNext\");\nrequire(\"./add/observable/pairs\");\nrequire(\"./add/observable/range\");\nrequire(\"./add/observable/using\");\nrequire(\"./add/observable/throw\");\nrequire(\"./add/observable/timer\");\nrequire(\"./add/observable/zip\");\n//dom\nrequire(\"./add/observable/dom/ajax\");\nrequire(\"./add/observable/dom/webSocket\");\n//internal/operators\nrequire(\"./add/operator/buffer\");\nrequire(\"./add/operator/bufferCount\");\nrequire(\"./add/operator/bufferTime\");\nrequire(\"./add/operator/bufferToggle\");\nrequire(\"./add/operator/bufferWhen\");\nrequire(\"./add/operator/catch\");\nrequire(\"./add/operator/combineAll\");\nrequire(\"./add/operator/combineLatest\");\nrequire(\"./add/operator/concat\");\nrequire(\"./add/operator/concatAll\");\nrequire(\"./add/operator/concatMap\");\nrequire(\"./add/operator/concatMapTo\");\nrequire(\"./add/operator/count\");\nrequire(\"./add/operator/dematerialize\");\nrequire(\"./add/operator/debounce\");\nrequire(\"./add/operator/debounceTime\");\nrequire(\"./add/operator/defaultIfEmpty\");\nrequire(\"./add/operator/delay\");\nrequire(\"./add/operator/delayWhen\");\nrequire(\"./add/operator/distinct\");\nrequire(\"./add/operator/distinctUntilChanged\");\nrequire(\"./add/operator/distinctUntilKeyChanged\");\nrequire(\"./add/operator/do\");\nrequire(\"./add/operator/exhaust\");\nrequire(\"./add/operator/exhaustMap\");\nrequire(\"./add/operator/expand\");\nrequire(\"./add/operator/elementAt\");\nrequire(\"./add/operator/filter\");\nrequire(\"./add/operator/finally\");\nrequire(\"./add/operator/find\");\nrequire(\"./add/operator/findIndex\");\nrequire(\"./add/operator/first\");\nrequire(\"./add/operator/groupBy\");\nrequire(\"./add/operator/ignoreElements\");\nrequire(\"./add/operator/isEmpty\");\nrequire(\"./add/operator/audit\");\nrequire(\"./add/operator/auditTime\");\nrequire(\"./add/operator/last\");\nrequire(\"./add/operator/let\");\nrequire(\"./add/operator/every\");\nrequire(\"./add/operator/map\");\nrequire(\"./add/operator/mapTo\");\nrequire(\"./add/operator/materialize\");\nrequire(\"./add/operator/max\");\nrequire(\"./add/operator/merge\");\nrequire(\"./add/operator/mergeAll\");\nrequire(\"./add/operator/mergeMap\");\nrequire(\"./add/operator/mergeMapTo\");\nrequire(\"./add/operator/mergeScan\");\nrequire(\"./add/operator/min\");\nrequire(\"./add/operator/multicast\");\nrequire(\"./add/operator/observeOn\");\nrequire(\"./add/operator/onErrorResumeNext\");\nrequire(\"./add/operator/pairwise\");\nrequire(\"./add/operator/partition\");\nrequire(\"./add/operator/pluck\");\nrequire(\"./add/operator/publish\");\nrequire(\"./add/operator/publishBehavior\");\nrequire(\"./add/operator/publishReplay\");\nrequire(\"./add/operator/publishLast\");\nrequire(\"./add/operator/race\");\nrequire(\"./add/operator/reduce\");\nrequire(\"./add/operator/repeat\");\nrequire(\"./add/operator/repeatWhen\");\nrequire(\"./add/operator/retry\");\nrequire(\"./add/operator/retryWhen\");\nrequire(\"./add/operator/sample\");\nrequire(\"./add/operator/sampleTime\");\nrequire(\"./add/operator/scan\");\nrequire(\"./add/operator/sequenceEqual\");\nrequire(\"./add/operator/share\");\nrequire(\"./add/operator/shareReplay\");\nrequire(\"./add/operator/single\");\nrequire(\"./add/operator/skip\");\nrequire(\"./add/operator/skipLast\");\nrequire(\"./add/operator/skipUntil\");\nrequire(\"./add/operator/skipWhile\");\nrequire(\"./add/operator/startWith\");\nrequire(\"./add/operator/subscribeOn\");\nrequire(\"./add/operator/switch\");\nrequire(\"./add/operator/switchMap\");\nrequire(\"./add/operator/switchMapTo\");\nrequire(\"./add/operator/take\");\nrequire(\"./add/operator/takeLast\");\nrequire(\"./add/operator/takeUntil\");\nrequire(\"./add/operator/takeWhile\");\nrequire(\"./add/operator/throttle\");\nrequire(\"./add/operator/throttleTime\");\nrequire(\"./add/operator/timeInterval\");\nrequire(\"./add/operator/timeout\");\nrequire(\"./add/operator/timeoutWith\");\nrequire(\"./add/operator/timestamp\");\nrequire(\"./add/operator/toArray\");\nrequire(\"./add/operator/toPromise\");\nrequire(\"./add/operator/window\");\nrequire(\"./add/operator/windowCount\");\nrequire(\"./add/operator/windowTime\");\nrequire(\"./add/operator/windowToggle\");\nrequire(\"./add/operator/windowWhen\");\nrequire(\"./add/operator/withLatestFrom\");\nrequire(\"./add/operator/zip\");\nrequire(\"./add/operator/zipAll\");\n/* tslint:disable:no-unused-variable */\nvar rxjs_2 = require(\"rxjs\");\nexports.Subscription = rxjs_2.Subscription;\nexports.ReplaySubject = rxjs_2.ReplaySubject;\nexports.BehaviorSubject = rxjs_2.BehaviorSubject;\nexports.Notification = rxjs_2.Notification;\nexports.EmptyError = rxjs_2.EmptyError;\nexports.ArgumentOutOfRangeError = rxjs_2.ArgumentOutOfRangeError;\nexports.ObjectUnsubscribedError = rxjs_2.ObjectUnsubscribedError;\nexports.UnsubscriptionError = rxjs_2.UnsubscriptionError;\nexports.pipe = rxjs_2.pipe;\nvar testing_1 = require(\"rxjs/testing\");\nexports.TestScheduler = testing_1.TestScheduler;\nvar rxjs_3 = require(\"rxjs\");\nexports.Subscriber = rxjs_3.Subscriber;\nexports.AsyncSubject = rxjs_3.AsyncSubject;\nexports.ConnectableObservable = rxjs_3.ConnectableObservable;\nexports.TimeoutError = rxjs_3.TimeoutError;\nexports.VirtualTimeScheduler = rxjs_3.VirtualTimeScheduler;\nvar ajax_1 = require(\"rxjs/ajax\");\nexports.AjaxResponse = ajax_1.AjaxResponse;\nexports.AjaxError = ajax_1.AjaxError;\nexports.AjaxTimeoutError = ajax_1.AjaxTimeoutError;\nvar rxjs_4 = require(\"rxjs\");\nvar internal_compatibility_3 = require(\"rxjs/internal-compatibility\");\nvar internal_compatibility_4 = require(\"rxjs/internal-compatibility\");\nexports.TimeInterval = internal_compatibility_4.TimeInterval;\nexports.Timestamp = internal_compatibility_4.Timestamp;\nvar _operators = require(\"rxjs/operators\");\nexports.operators = _operators;\n/* tslint:enable:no-unused-variable */\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {Scheduler} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {Scheduler} asap Schedules on the micro task queue, which is the same\n * queue used for promises. Basically after the current job, but before the next\n * job. Use this for asynchronous conversions.\n * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting\n */\nvar Scheduler = {\n    asap: rxjs_4.asapScheduler,\n    queue: rxjs_4.queueScheduler,\n    animationFrame: rxjs_4.animationFrameScheduler,\n    async: rxjs_4.asyncScheduler\n};\nexports.Scheduler = Scheduler;\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\nvar Symbol = {\n    rxSubscriber: internal_compatibility_3.rxSubscriber,\n    observable: internal_compatibility_3.observable,\n    iterator: internal_compatibility_3.iterator\n};\nexports.Symbol = Symbol;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.bindCallback = rxjs_1.bindCallback;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.bindNodeCallback = rxjs_1.bindNodeCallback;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.combineLatest = rxjs_1.combineLatest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.concat = rxjs_1.concat;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.defer = rxjs_1.defer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar ajax_1 = require(\"rxjs/ajax\");\nrxjs_1.Observable.ajax = ajax_1.ajax;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar webSocket_1 = require(\"rxjs/webSocket\");\nrxjs_1.Observable.webSocket = webSocket_1.webSocket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.empty = rxjs_1.empty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.forkJoin = rxjs_1.forkJoin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.from = rxjs_1.from;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.fromEvent = rxjs_1.fromEvent;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.fromEventPattern = rxjs_1.fromEventPattern;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.fromPromise = rxjs_1.from;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.generate = rxjs_1.generate;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.if = rxjs_1.iif;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.interval = rxjs_1.interval;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.merge = rxjs_1.merge;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nfunction staticNever() {\n    return rxjs_1.NEVER;\n}\nexports.staticNever = staticNever;\nrxjs_1.Observable.never = staticNever;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.of = rxjs_1.of;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.onErrorResumeNext = rxjs_1.onErrorResumeNext;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.pairs = rxjs_1.pairs;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.race = rxjs_1.race;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.range = rxjs_1.range;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.throw = rxjs_1.throwError;\nrxjs_1.Observable.throwError = rxjs_1.throwError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.timer = rxjs_1.timer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.using = rxjs_1.using;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nrxjs_1.Observable.zip = rxjs_1.zip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar audit_1 = require(\"../../operator/audit\");\nrxjs_1.Observable.prototype.audit = audit_1.audit;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar auditTime_1 = require(\"../../operator/auditTime\");\nrxjs_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar buffer_1 = require(\"../../operator/buffer\");\nrxjs_1.Observable.prototype.buffer = buffer_1.buffer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar bufferCount_1 = require(\"../../operator/bufferCount\");\nrxjs_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar bufferTime_1 = require(\"../../operator/bufferTime\");\nrxjs_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar bufferToggle_1 = require(\"../../operator/bufferToggle\");\nrxjs_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar bufferWhen_1 = require(\"../../operator/bufferWhen\");\nrxjs_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar catch_1 = require(\"../../operator/catch\");\nrxjs_1.Observable.prototype.catch = catch_1._catch;\nrxjs_1.Observable.prototype._catch = catch_1._catch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar combineAll_1 = require(\"../../operator/combineAll\");\nrxjs_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar combineLatest_1 = require(\"../../operator/combineLatest\");\nrxjs_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar concat_1 = require(\"../../operator/concat\");\nrxjs_1.Observable.prototype.concat = concat_1.concat;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar concatAll_1 = require(\"../../operator/concatAll\");\nrxjs_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar concatMap_1 = require(\"../../operator/concatMap\");\nrxjs_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar concatMapTo_1 = require(\"../../operator/concatMapTo\");\nrxjs_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar count_1 = require(\"../../operator/count\");\nrxjs_1.Observable.prototype.count = count_1.count;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar debounce_1 = require(\"../../operator/debounce\");\nrxjs_1.Observable.prototype.debounce = debounce_1.debounce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar debounceTime_1 = require(\"../../operator/debounceTime\");\nrxjs_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar defaultIfEmpty_1 = require(\"../../operator/defaultIfEmpty\");\nrxjs_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar delay_1 = require(\"../../operator/delay\");\nrxjs_1.Observable.prototype.delay = delay_1.delay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar delayWhen_1 = require(\"../../operator/delayWhen\");\nrxjs_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar dematerialize_1 = require(\"../../operator/dematerialize\");\nrxjs_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar distinct_1 = require(\"../../operator/distinct\");\nrxjs_1.Observable.prototype.distinct = distinct_1.distinct;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar distinctUntilChanged_1 = require(\"../../operator/distinctUntilChanged\");\nrxjs_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar distinctUntilKeyChanged_1 = require(\"../../operator/distinctUntilKeyChanged\");\nrxjs_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar do_1 = require(\"../../operator/do\");\nrxjs_1.Observable.prototype.do = do_1._do;\nrxjs_1.Observable.prototype._do = do_1._do;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar elementAt_1 = require(\"../../operator/elementAt\");\nrxjs_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar every_1 = require(\"../../operator/every\");\nrxjs_1.Observable.prototype.every = every_1.every;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar exhaust_1 = require(\"../../operator/exhaust\");\nrxjs_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar exhaustMap_1 = require(\"../../operator/exhaustMap\");\nrxjs_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar expand_1 = require(\"../../operator/expand\");\nrxjs_1.Observable.prototype.expand = expand_1.expand;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar filter_1 = require(\"../../operator/filter\");\nrxjs_1.Observable.prototype.filter = filter_1.filter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar finally_1 = require(\"../../operator/finally\");\nrxjs_1.Observable.prototype.finally = finally_1._finally;\nrxjs_1.Observable.prototype._finally = finally_1._finally;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar find_1 = require(\"../../operator/find\");\nrxjs_1.Observable.prototype.find = find_1.find;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar findIndex_1 = require(\"../../operator/findIndex\");\nrxjs_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar first_1 = require(\"../../operator/first\");\nrxjs_1.Observable.prototype.first = first_1.first;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar groupBy_1 = require(\"../../operator/groupBy\");\nrxjs_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar ignoreElements_1 = require(\"../../operator/ignoreElements\");\nrxjs_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar isEmpty_1 = require(\"../../operator/isEmpty\");\nrxjs_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar last_1 = require(\"../../operator/last\");\nrxjs_1.Observable.prototype.last = last_1.last;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar let_1 = require(\"../../operator/let\");\nrxjs_1.Observable.prototype.let = let_1.letProto;\nrxjs_1.Observable.prototype.letBind = let_1.letProto;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar map_1 = require(\"../../operator/map\");\nrxjs_1.Observable.prototype.map = map_1.map;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar mapTo_1 = require(\"../../operator/mapTo\");\nrxjs_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar materialize_1 = require(\"../../operator/materialize\");\nrxjs_1.Observable.prototype.materialize = materialize_1.materialize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar max_1 = require(\"../../operator/max\");\nrxjs_1.Observable.prototype.max = max_1.max;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar merge_1 = require(\"../../operator/merge\");\nrxjs_1.Observable.prototype.merge = merge_1.merge;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar mergeAll_1 = require(\"../../operator/mergeAll\");\nrxjs_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar mergeMap_1 = require(\"../../operator/mergeMap\");\nrxjs_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nrxjs_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar mergeMapTo_1 = require(\"../../operator/mergeMapTo\");\nrxjs_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nrxjs_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar mergeScan_1 = require(\"../../operator/mergeScan\");\nrxjs_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar min_1 = require(\"../../operator/min\");\nrxjs_1.Observable.prototype.min = min_1.min;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar multicast_1 = require(\"../../operator/multicast\");\nrxjs_1.Observable.prototype.multicast = multicast_1.multicast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar observeOn_1 = require(\"../../operator/observeOn\");\nrxjs_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar onErrorResumeNext_1 = require(\"../../operator/onErrorResumeNext\");\nrxjs_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar pairwise_1 = require(\"../../operator/pairwise\");\nrxjs_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar partition_1 = require(\"../../operator/partition\");\nrxjs_1.Observable.prototype.partition = partition_1.partition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar pluck_1 = require(\"../../operator/pluck\");\nrxjs_1.Observable.prototype.pluck = pluck_1.pluck;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar publish_1 = require(\"../../operator/publish\");\nrxjs_1.Observable.prototype.publish = publish_1.publish;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar publishBehavior_1 = require(\"../../operator/publishBehavior\");\nrxjs_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar publishLast_1 = require(\"../../operator/publishLast\");\nrxjs_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar publishReplay_1 = require(\"../../operator/publishReplay\");\nrxjs_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar race_1 = require(\"../../operator/race\");\nrxjs_1.Observable.prototype.race = race_1.race;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar reduce_1 = require(\"../../operator/reduce\");\nrxjs_1.Observable.prototype.reduce = reduce_1.reduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar repeat_1 = require(\"../../operator/repeat\");\nrxjs_1.Observable.prototype.repeat = repeat_1.repeat;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar repeatWhen_1 = require(\"../../operator/repeatWhen\");\nrxjs_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar retry_1 = require(\"../../operator/retry\");\nrxjs_1.Observable.prototype.retry = retry_1.retry;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar retryWhen_1 = require(\"../../operator/retryWhen\");\nrxjs_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar sample_1 = require(\"../../operator/sample\");\nrxjs_1.Observable.prototype.sample = sample_1.sample;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar sampleTime_1 = require(\"../../operator/sampleTime\");\nrxjs_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar scan_1 = require(\"../../operator/scan\");\nrxjs_1.Observable.prototype.scan = scan_1.scan;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar sequenceEqual_1 = require(\"../../operator/sequenceEqual\");\nrxjs_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar share_1 = require(\"../../operator/share\");\nrxjs_1.Observable.prototype.share = share_1.share;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar shareReplay_1 = require(\"../../operator/shareReplay\");\nrxjs_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar single_1 = require(\"../../operator/single\");\nrxjs_1.Observable.prototype.single = single_1.single;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar skip_1 = require(\"../../operator/skip\");\nrxjs_1.Observable.prototype.skip = skip_1.skip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar skipLast_1 = require(\"../../operator/skipLast\");\nrxjs_1.Observable.prototype.skipLast = skipLast_1.skipLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar skipUntil_1 = require(\"../../operator/skipUntil\");\nrxjs_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar skipWhile_1 = require(\"../../operator/skipWhile\");\nrxjs_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar startWith_1 = require(\"../../operator/startWith\");\nrxjs_1.Observable.prototype.startWith = startWith_1.startWith;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar subscribeOn_1 = require(\"../../operator/subscribeOn\");\nrxjs_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar switch_1 = require(\"../../operator/switch\");\nrxjs_1.Observable.prototype.switch = switch_1._switch;\nrxjs_1.Observable.prototype._switch = switch_1._switch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar switchMap_1 = require(\"../../operator/switchMap\");\nrxjs_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar switchMapTo_1 = require(\"../../operator/switchMapTo\");\nrxjs_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar take_1 = require(\"../../operator/take\");\nrxjs_1.Observable.prototype.take = take_1.take;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar takeLast_1 = require(\"../../operator/takeLast\");\nrxjs_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar takeUntil_1 = require(\"../../operator/takeUntil\");\nrxjs_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar takeWhile_1 = require(\"../../operator/takeWhile\");\nrxjs_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar throttle_1 = require(\"../../operator/throttle\");\nrxjs_1.Observable.prototype.throttle = throttle_1.throttle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar throttleTime_1 = require(\"../../operator/throttleTime\");\nrxjs_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar timeInterval_1 = require(\"../../operator/timeInterval\");\nrxjs_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar timeout_1 = require(\"../../operator/timeout\");\nrxjs_1.Observable.prototype.timeout = timeout_1.timeout;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar timeoutWith_1 = require(\"../../operator/timeoutWith\");\nrxjs_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar timestamp_1 = require(\"../../operator/timestamp\");\nrxjs_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar toArray_1 = require(\"../../operator/toArray\");\nrxjs_1.Observable.prototype.toArray = toArray_1.toArray;\n","// HACK: does nothing, because `toPromise` now lives on the `Observable` itself.\n// leaving this module here to prevent breakage.\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar window_1 = require(\"../../operator/window\");\nrxjs_1.Observable.prototype.window = window_1.window;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar windowCount_1 = require(\"../../operator/windowCount\");\nrxjs_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar windowTime_1 = require(\"../../operator/windowTime\");\nrxjs_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar windowToggle_1 = require(\"../../operator/windowToggle\");\nrxjs_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar windowWhen_1 = require(\"../../operator/windowWhen\");\nrxjs_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar withLatestFrom_1 = require(\"../../operator/withLatestFrom\");\nrxjs_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar zip_1 = require(\"../../operator/zip\");\nrxjs_1.Observable.prototype.zip = zip_1.zipProto;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar zipAll_1 = require(\"../../operator/zipAll\");\nrxjs_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return operators_1.audit(durationSelector)(this);\n}\nexports.audit = audit;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.auditTime(duration, scheduler)(this);\n}\nexports.auditTime = auditTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return operators_1.buffer(closingNotifier)(this);\n}\nexports.buffer = buffer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return operators_1.bufferCount(bufferSize, startBufferEvery)(this);\n}\nexports.bufferCount = bufferCount;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=asyncScheduler] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = rxjs_1.asyncScheduler;\n    if (internal_compatibility_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return operators_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n}\nexports.bufferTime = bufferTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return operators_1.bufferToggle(openings, closingSelector)(this);\n}\nexports.bufferToggle = bufferToggle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return operators_1.bufferWhen(closingSelector)(this);\n}\nexports.bufferWhen = bufferWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    return operators_1.catchError(selector)(this);\n}\nexports._catch = _catch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts a higher-order Observable into a first-order Observable by waiting\n * for the outer Observable to complete, then applying {@link combineLatest}.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n * {@link combineLatest} when the Observable-of-Observables completes.</span>\n *\n * <img src=\"./img/combineAll.png\" width=\"100%\">\n *\n * Takes an Observable of Observables, and collects all Observables from it.\n * Once the outer Observable completes, it subscribes to all collected\n * Observables and combines their values using the {@link combineLatest}\n * strategy, such that:\n * - Every time an inner Observable emits, the output Observable emits.\n * - When the returned observable emits, it emits all of the latest values by:\n *   - If a `project` function is provided, it is called with each recent value\n *     from each inner Observable in whatever order they arrived, and the result\n *     of the `project` function is what is emitted by the output Observable.\n *   - If there is no `project` function, an array of all of the most recent\n *     values is emitted by the output Observable.\n *\n * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev =>\n *   Rx.Observable.interval(Math.random()*2000).take(3)\n * ).take(2);\n * var result = higherOrder.combineAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function} [project] An optional function to map the most recent\n * values from each inner Observable into a new result. Takes each of the most\n * recent values from each collected inner Observable as arguments, in order.\n * @return {Observable} An Observable of projected results or arrays of recent\n * values.\n * @method combineAll\n * @owner Observable\n */\nfunction combineAll(project) {\n    return operators_1.combineAll(project)(this);\n}\nexports.combineAll = combineAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && internal_compatibility_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return this.lift.call(rxjs_1.of.apply(void 0, [this].concat(observables)), new internal_compatibility_1.CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return this.lift.call(rxjs_1.concat.apply(void 0, [this].concat(observables)));\n}\nexports.concat = concat;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return operators_1.concatAll()(this);\n}\nexports.concatAll = concatAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project) {\n    return operators_1.concatMap(project)(this);\n}\nexports.concatMap = concatMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable) {\n    return operators_1.concatMapTo(innerObservable)(this);\n}\nexports.concatMapTo = concatMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return operators_1.count(predicate)(this);\n}\nexports.count = count;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return operators_1.debounce(durationSelector)(this);\n}\nexports.debounce = debounce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return operators_1.defaultIfEmpty(defaultValue)(this);\n}\nexports.defaultIfEmpty = defaultIfEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=asyncScheduler] The SchedulerLike to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.delay(delay, scheduler)(this);\n}\nexports.delay = delay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    return operators_1.delayWhen(delayDurationSelector, subscriptionDelay)(this);\n}\nexports.delayWhen = delayWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return operators_1.dematerialize()(this);\n}\nexports.dematerialize = dematerialize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return operators_1.distinct(keySelector, flushes)(this);\n}\nexports.distinct = distinct;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return operators_1.distinctUntilChanged(compare, keySelector)(this);\n}\nexports.distinctUntilChanged = distinctUntilChanged;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\n// tslint:disable-next-line:max-line-length\nfunction distinctUntilKeyChanged(key, compare) {\n    return operators_1.distinctUntilKeyChanged(key, compare)(this);\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return operators_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return operators_1.elementAt.apply(undefined, arguments)(this);\n}\nexports.elementAt = elementAt;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return operators_1.every(predicate, thisArg)(this);\n}\nexports.every = every;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n */\nfunction exhaust() {\n    return operators_1.exhaust()(this);\n}\nexports.exhaust = exhaust;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = fromEvent(document, 'click');\n * var result = clicks.pipe(exhaustMap((ev) => Rx.Observable.interval(1000).take(5)));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n */\nfunction exhaustMap(project) {\n    return operators_1.exhaustMap(project)(this);\n}\nexports.exhaustMap = exhaustMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return operators_1.expand(project, concurrent, scheduler)(this);\n}\nexports.expand = expand;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return operators_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete, error or unsubscribe.\n *\n * <span class=\"informal\">Ensure a given function will be called when a stream ends, no matter why it ended.</span>\n *\n * `finally` method accepts as a single parameter a function. This function does not accept any parameters and\n * should not return anything. It will be called whenever source Observable completes, errors or is unsubscribed,\n * which makes it good candidate to perform any necessary clean up or side effects when Observable terminates,\n * no matter how or why it terminated.\n *\n * Observable returned by `finally` will simply mirror source Observable - each time it is subscribed, source\n * Observable will be subscribed underneath.\n *\n * Note that behavior of `finally` will be repeated per every subscription, so if resulting Observable has\n * many subscribers, function passed to `finally` might be potentially called multiple times.\n *\n * Remember also that `finally` differs quite a lot from passing complete or error handler to {@link subscribe}. It will\n * return an Observable which can be further chained, while `subscribe` returns Subscription, basically ending Observable\n * chain. Function passed to `finally` will be called also when consumer of resulting Observable unsubscribes from it,\n * while handlers passed to `subscribe` will not (even complete handler). But most importantly, `finally` does not start\n * an execution of source Observable, like `subscribe` does, allowing you to set up all necessary hooks before\n * passing Observable further, even without specific knowledge how or when it will be used.\n *\n *\n * @example <caption>Call finally after complete notification</caption>\n * Rx.Observable.of(1, 2, 3)\n * .finally(() => console.log('I was finalized!'))\n * .map(x => x * 2) // `finally` returns an Observable, so we still can chain operators.\n * .subscribe(\n *   val => console.log(val),\n *   err => {},\n *   () => console.log('I completed!')\n * );\n *\n * // Logs:\n * // 1\n * // 2\n * // 3\n * // \"I completed!\"\n * // \"I was finalized!\"\n *\n *\n *\n * @example <caption>Call finally after consumer unsubscribes</caption>\n * const o = Rx.Observable.interval(1000)\n * .finally(() => console.log('Timer stopped'));\n *\n * const subscription = o.subscribe(\n *   val => console.log(val),\n *   err => {},\n *   () => console.log('Complete!') // Will not be called, since complete handler\n * );                               // does not react to unsubscription, just to\n *                                  // complete notification sent by the Observable itself.\n *\n * setTimeout(() => subscription.unsubscribe(), 2500);\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // \"Timer stopped\" after 2.5s\n *\n * @see {@link using}\n *\n * @param {function} callback Function to be called when source terminates (completes, errors or is unsubscribed).\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @name finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return operators_1.finalize(callback)(this);\n}\nexports._finally = _finally;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    return operators_1.find(predicate, thisArg)(this);\n}\nexports.find = find;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return operators_1.findIndex(predicate, thisArg)(this);\n}\nexports.findIndex = findIndex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {T} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return operators_1.first.apply(void 0, args)(this);\n}\nexports.first = first;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return operators_1.groupBy(keySelector, elementSelector, durationSelector, subjectSelector)(this);\n}\nexports.groupBy = groupBy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return operators_1.ignoreElements()(this);\n}\nexports.ignoreElements = ignoreElements;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n *\n * <img src=\"./img/isEmpty.png\" width=\"100%\">\n *\n * @return {Observable} An Observable that emits a Boolean.\n * @method isEmpty\n * @owner Observable\n */\nfunction isEmpty() {\n    return operators_1.isEmpty()(this);\n}\nexports.isEmpty = isEmpty;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} [predicate] - The condition any source emitted item has to satisfy.\n * @param {any} [defaultValue] - The default value to use if the predicate isn't\n * satisfied, or no values were emitted (if no predicate).\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return operators_1.last.apply(void 0, args)(this);\n}\nexports.last = last;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\nfunction letProto(func) {\n    return func(this);\n}\nexports.letProto = letProto;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    return operators_1.map(project, thisArg)(this);\n}\nexports.map = map;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return operators_1.mapTo(value)(this);\n}\nexports.mapTo = mapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return operators_1.materialize()(this);\n}\nexports.materialize = materialize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    return operators_1.max(comparer)(this);\n}\nexports.max = max;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return this.lift.call(rxjs_1.merge.apply(void 0, [this].concat(observables)));\n}\nexports.merge = merge;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return operators_1.mergeAll(concurrent)(this);\n}\nexports.mergeAll = mergeAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return operators_1.mergeMap(project, concurrent)(this);\n}\nexports.mergeMap = mergeMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable`.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return operators_1.mergeMapTo(innerObservable, concurrent)(this);\n}\nexports.mergeMapTo = mergeMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return operators_1.mergeScan(accumulator, seed, concurrent)(this);\n}\nexports.mergeScan = mergeScan;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    return operators_1.min(comparer)(this);\n}\nexports.min = min;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Allows source Observable to be subscribed only once with a Subject of choice,\n * while still sharing its values between multiple subscribers.\n *\n * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * `multicast` is an operator that works in two modes.\n *\n * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\n * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\n * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\n * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\n * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\n * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\n * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\n * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\n *\n * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\n * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\n * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\n * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\n * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\n * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\n * ConnectableObservable, use `refCount`.\n *\n * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\n * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\n * as well, which should be the input stream modified by any operators you want. Note that in this\n * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\n * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\n * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\n * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\n * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\n * but you want to subscribe to that Observable only once, this is the mode you would use.\n *\n * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\n * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\n * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\n * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\n * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\n * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\n * just wrappers around `multicast`, with a specific Subject hardcoded inside.\n *\n * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\n * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\n *\n * @example <caption>Use ConnectableObservable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const connectableSeconds = seconds.multicast(new Subject());\n *\n * connectableSeconds.subscribe(value => console.log('first: ' + value));\n * connectableSeconds.subscribe(value => console.log('second: ' + value));\n *\n * // At this point still nothing happens, even though we subscribed twice.\n *\n * connectableSeconds.connect();\n *\n * // From now on `seconds` are being logged to the console,\n * // twice per every second. `seconds` Observable was however only subscribed once,\n * // so under the hood Observable.interval had only one clock started.\n *\n * @example <caption>Use selector</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds\n *     .multicast(\n *         () => new Subject(),\n *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\n *                                         // Because we are inside selector, `seconds` is subscribed once,\n *     )                                   // thus starting only one clock used internally by Observable.interval.\n *     .subscribe();\n *\n * @see {@link publish}\n * @see {@link publishLast}\n * @see {@link publishBehavior}\n * @see {@link publishReplay}\n * @see {@link share}\n * @see {@link shareReplay}\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\n * which the source sequence's elements will be multicast to the selector function input Observable or\n * ConnectableObservable returned by the operator.\n * @param {Function} [selector] - Optional selector function that can use the input stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the input source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\n * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\n *\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    return operators_1.multicast(subjectOrSubjectFactory, selector)(this);\n}\nexports.multicast = multicast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return operators_1.observeOn(scheduler, delay)(this);\n}\nexports.observeOn = observeOn;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i] = arguments[_i];\n    }\n    return operators_1.onErrorResumeNext.apply(void 0, nextSources)(this);\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return operators_1.pairwise()(this);\n}\nexports.pairwise = pairwise;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return operators_1.partition(predicate, thisArg)(this);\n}\nexports.partition = partition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i] = arguments[_i];\n    }\n    return operators_1.pluck.apply(void 0, properties)(this);\n}\nexports.pluck = pluck;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return operators_1.publish(selector)(this);\n}\nexports.publish = publish;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return operators_1.publishBehavior(value)(this);\n}\nexports.publishBehavior = publishBehavior;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * @return {ConnectableObservable<T>}\n * @method publishLast\n * @owner Observable\n */\nfunction publishLast() {\n    //TODO(benlesh): correct type-flow through here.\n    return operators_1.publishLast()(this);\n}\nexports.publishLast = publishLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * @param bufferSize\n * @param windowTime\n * @param selectorOrScheduler\n * @param scheduler\n * @return {Observable<T> | ConnectableObservable<T>}\n * @method publishReplay\n * @owner Observable\n */\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    return operators_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);\n}\nexports.publishReplay = publishReplay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return operators_1.race.apply(void 0, observables)(this);\n}\nexports.race = race;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        return operators_1.reduce(accumulator, seed)(this);\n    }\n    return operators_1.reduce(accumulator)(this);\n}\nexports.reduce = reduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return operators_1.repeat(count)(this);\n}\nexports.repeat = repeat;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return operators_1.repeatWhen(notifier)(this);\n}\nexports.repeatWhen = repeatWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return operators_1.retry(count)(this);\n}\nexports.retry = retry;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return operators_1.retryWhen(notifier)(this);\n}\nexports.retryWhen = retryWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return operators_1.sample(notifier)(this);\n}\nexports.sample = sample;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.sampleTime(period, scheduler)(this);\n}\nexports.sampleTime = sampleTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    if (arguments.length >= 2) {\n        return operators_1.scan(accumulator, seed)(this);\n    }\n    return operators_1.scan(accumulator)(this);\n}\nexports.scan = scan;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return operators_1.sequenceEqual(compareTo, comparor)(this);\n}\nexports.sequenceEqual = sequenceEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n *\n * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n * re-emit \"test\" to new subscriptions.\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return operators_1.share()(this);\n}\nexports.share = share;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\nfunction shareReplay(configOrBufferSize, windowTime, scheduler) {\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        return operators_1.shareReplay(configOrBufferSize)(this);\n    }\n    return operators_1.shareReplay(configOrBufferSize, windowTime, scheduler)(this);\n}\nexports.shareReplay = shareReplay;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return operators_1.single(predicate)(this);\n}\nexports.single = single;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return operators_1.skip(count)(this);\n}\nexports.skip = skip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return operators_1.skipLast(count)(this);\n}\nexports.skipLast = skipLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return operators_1.skipUntil(notifier)(this);\n}\nexports.skipUntil = skipUntil;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return operators_1.skipWhile(predicate)(this);\n}\nexports.skipWhile = skipWhile;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i] = arguments[_i];\n    }\n    return operators_1.startWith.apply(void 0, array)(this);\n}\nexports.startWith = startWith;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n .\n * @method subscribeOn\n * @owner Observable\n */\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return operators_1.subscribeOn(scheduler, delay)(this);\n}\nexports.subscribeOn = subscribeOn;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nfunction _switch() {\n    return operators_1.switchAll()(this);\n}\nexports._switch = _switch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project) {\n    return operators_1.switchMap(project)(this);\n}\nexports.switchMap = switchMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable) {\n    return operators_1.switchMapTo(innerObservable)(this);\n}\nexports.switchMapTo = switchMapTo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return operators_1.take(count)(this);\n}\nexports.take = take;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    return operators_1.takeLast(count)(this);\n}\nexports.takeLast = takeLast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return operators_1.takeUntil(notifier)(this);\n}\nexports.takeUntil = takeUntil;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return operators_1.takeWhile(predicate)(this);\n}\nexports.takeWhile = takeWhile;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nfunction throttle(durationSelector, config) {\n    if (config === void 0) { config = internal_compatibility_1.defaultThrottleConfig; }\n    return operators_1.throttle(durationSelector, config)(this);\n}\nexports.throttle = throttle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=asyncScheduler] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    if (config === void 0) { config = internal_compatibility_1.defaultThrottleConfig; }\n    return operators_1.throttleTime(duration, scheduler, config)(this);\n}\nexports.throttleTime = throttleTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * @param scheduler\n * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timeInterval\n * @owner Observable\n */\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.timeInterval(scheduler)(this);\n}\nexports.timeInterval = timeInterval;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.timeout(due, scheduler)(this);\n}\nexports.timeout = timeout;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.timeoutWith(due, withObservable, scheduler)(this);\n}\nexports.timeoutWith = timeoutWith;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = rxjs_1.asyncScheduler; }\n    return operators_1.timestamp(scheduler)(this);\n}\nexports.timestamp = timestamp;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * <img src=\"./img/toArray.png\" width=\"100%\">\n *\n * `toArray` will wait until the source Observable completes\n * before emitting the array containing all emissions.\n * When the source Observable errors no array will be emitted.\n *\n * @example <caption>Create array from input</caption>\n * const input = Rx.Observable.interval(100).take(4);\n *\n * input.toArray()\n *   .subscribe(arr => console.log(arr)); // [0,1,2,3]\n *\n * @see {@link buffer}\n *\n * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n * @method toArray\n * @owner Observable\n */\nfunction toArray() {\n    return operators_1.toArray()(this);\n}\nexports.toArray = toArray;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return operators_1.window(windowBoundaries)(this);\n}\nexports.window = window;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return operators_1.windowCount(windowSize, startWindowEvery)(this);\n}\nexports.windowCount = windowCount;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar internal_compatibility_1 = require(\"rxjs/internal-compatibility\");\nvar operators_1 = require(\"rxjs/operators\");\nfunction windowTime(windowTimeSpan) {\n    var scheduler = rxjs_1.asyncScheduler;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (internal_compatibility_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (internal_compatibility_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (internal_compatibility_1.isNumeric(arguments[2])) {\n        maxWindowSize = Number(arguments[2]);\n    }\n    if (internal_compatibility_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (internal_compatibility_1.isNumeric(arguments[1])) {\n        windowCreationInterval = Number(arguments[1]);\n    }\n    return operators_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);\n}\nexports.windowTime = windowTime;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return operators_1.windowToggle(openings, closingSelector)(this);\n}\nexports.windowToggle = windowToggle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return operators_1.windowWhen(closingSelector)(this);\n}\nexports.windowWhen = windowWhen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return operators_1.withLatestFrom.apply(void 0, args)(this);\n}\nexports.withLatestFrom = withLatestFrom;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zipProto() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return this.lift.call(rxjs_1.zip.apply(void 0, [this].concat(observables)));\n}\nexports.zipProto = zipProto;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * @param project\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method zipAll\n * @owner Observable\n */\nfunction zipAll(project) {\n    return operators_1.zipAll(project)(this);\n}\nexports.zipAll = zipAll;\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"rxjs-compat/Observable\"));\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"rxjs-compat\"));\n","export { ajax } from '../internal/observable/dom/ajax';\nexport { AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\n","export { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { observable } from './internal/symbol/observable';\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\nexport { Notification, NotificationKind } from './internal/Notification';\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { TimeoutError } from './internal/util/TimeoutError';\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\nexport { config } from './internal/config';\n","export { config } from '../internal/config';\nexport { InnerSubscriber } from '../internal/InnerSubscriber';\nexport { OuterSubscriber } from '../internal/OuterSubscriber';\nexport { Scheduler } from '../internal/Scheduler';\nexport { AnonymousSubject } from '../internal/Subject';\nexport { SubjectSubscription } from '../internal/SubjectSubscription';\nexport { Subscriber } from '../internal/Subscriber';\nexport { fromPromise } from '../internal/observable/fromPromise';\nexport { fromIterable } from '../internal/observable/fromIterable';\nexport { ajax } from '../internal/observable/dom/ajax';\nexport { webSocket } from '../internal/observable/dom/webSocket';\nexport { ajaxGet, ajaxPost, ajaxDelete, ajaxPut, ajaxPatch, ajaxGetJSON, AjaxObservable, AjaxSubscriber, AjaxResponse, AjaxError, AjaxTimeoutError } from '../internal/observable/dom/AjaxObservable';\nexport { WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\nexport { CombineLatestOperator } from '../internal/observable/combineLatest';\nexport { dispatch } from '../internal/observable/range';\nexport { SubscribeOnObservable } from '../internal/observable/SubscribeOnObservable';\nexport { Timestamp } from '../internal/operators/timestamp';\nexport { TimeInterval } from '../internal/operators/timeInterval';\nexport { GroupedObservable } from '../internal/operators/groupBy';\nexport { defaultThrottleConfig } from '../internal/operators/throttle';\nexport { rxSubscriber } from '../internal/symbol/rxSubscriber';\nexport { iterator } from '../internal/symbol/iterator';\nexport { observable } from '../internal/symbol/observable';\nexport { ArgumentOutOfRangeError } from '../internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from '../internal/util/EmptyError';\nexport { Immediate } from '../internal/util/Immediate';\nexport { ObjectUnsubscribedError } from '../internal/util/ObjectUnsubscribedError';\nexport { TimeoutError } from '../internal/util/TimeoutError';\nexport { UnsubscriptionError } from '../internal/util/UnsubscriptionError';\nexport { applyMixins } from '../internal/util/applyMixins';\nexport { errorObject } from '../internal/util/errorObject';\nexport { hostReportError } from '../internal/util/hostReportError';\nexport { identity } from '../internal/util/identity';\nexport { isArray } from '../internal/util/isArray';\nexport { isArrayLike } from '../internal/util/isArrayLike';\nexport { isDate } from '../internal/util/isDate';\nexport { isFunction } from '../internal/util/isFunction';\nexport { isIterable } from '../internal/util/isIterable';\nexport { isNumeric } from '../internal/util/isNumeric';\nexport { isObject } from '../internal/util/isObject';\nexport { isInteropObservable as isObservable } from '../internal/util/isInteropObservable';\nexport { isPromise } from '../internal/util/isPromise';\nexport { isScheduler } from '../internal/util/isScheduler';\nexport { noop } from '../internal/util/noop';\nexport { not } from '../internal/util/not';\nexport { pipe } from '../internal/util/pipe';\nexport { root } from '../internal/util/root';\nexport { subscribeTo } from '../internal/util/subscribeTo';\nexport { subscribeToArray } from '../internal/util/subscribeToArray';\nexport { subscribeToIterable } from '../internal/util/subscribeToIterable';\nexport { subscribeToObservable } from '../internal/util/subscribeToObservable';\nexport { subscribeToPromise } from '../internal/util/subscribeToPromise';\nexport { subscribeToResult } from '../internal/util/subscribeToResult';\nexport { toSubscriber } from '../internal/util/toSubscriber';\nexport { tryCatch } from '../internal/util/tryCatch';\n","import { Subject } from './Subject';\nimport { Subscription } from './Subscription';\nexport class AsyncSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    _subscribe(subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        return super._subscribe(subscriber);\n    }\n    next(value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    }\n    error(error) {\n        if (!this.hasCompleted) {\n            super.error(error);\n        }\n    }\n    complete() {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            super.next(this.value);\n        }\n        super.complete();\n    }\n}\n","import { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nexport var NotificationKind;\n(function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n})(NotificationKind || (NotificationKind = {}));\nexport class Notification {\n    constructor(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    observe(observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    }\n    do(next, error, complete) {\n        const kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    }\n    accept(nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    }\n    toObservable() {\n        const kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return of(this.value);\n            case 'E':\n                return throwError(this.error);\n            case 'C':\n                return empty();\n        }\n        throw new Error('unexpected notification kind value');\n    }\n    static createNext(value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    }\n    static createError(err) {\n        return new Notification('E', undefined, err);\n    }\n    static createComplete() {\n        return Notification.completeNotification;\n    }\n}\nNotification.completeNotification = new Notification('C');\nNotification.undefinedValueNotification = new Notification('N', undefined);\n","import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        if (!this.isStopped) {\n            const _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n","export class Scheduler {\n    constructor(SchedulerAction, now = Scheduler.now) {\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    schedule(work, delay = 0, state) {\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    }\n}\nScheduler.now = () => Date.now();\n","import { Observable } from '../Observable';\nimport { asap } from '../scheduler/asap';\nimport { isNumeric } from '../util/isNumeric';\nexport class SubscribeOnObservable extends Observable {\n    constructor(source, delayTime = 0, scheduler = asap) {\n        super();\n        this.source = source;\n        this.delayTime = delayTime;\n        this.scheduler = scheduler;\n        if (!isNumeric(delayTime) || delayTime < 0) {\n            this.delayTime = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = asap;\n        }\n    }\n    static create(source, delay = 0, scheduler = asap) {\n        return new SubscribeOnObservable(source, delay, scheduler);\n    }\n    static dispatch(arg) {\n        const { source, subscriber } = arg;\n        return this.add(source.subscribe(subscriber));\n    }\n    _subscribe(subscriber) {\n        const delay = this.delayTime;\n        const source = this.source;\n        const scheduler = this.scheduler;\n        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n            source, subscriber\n        });\n    }\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isArray } from '../util/isArray';\nimport { isScheduler } from '../util/isScheduler';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(map((args) => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const context = this;\n        let subject;\n        const params = {\n            context,\n            subject,\n            callbackFunc,\n            scheduler,\n        };\n        return new Observable(subscriber => {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                const state = {\n                    args, subscriber, params,\n                };\n                return scheduler.schedule(dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    const self = this;\n    const { args, subscriber, params } = state;\n    const { callbackFunc, context, scheduler } = params;\n    let { subject } = params;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        const handler = (...innerArgs) => {\n            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    const { value, subject } = state;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    const { err, subject } = state;\n    subject.error(err);\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const params = {\n            subject: undefined,\n            args,\n            callbackFunc,\n            scheduler,\n            context: this,\n        };\n        return new Observable(subscriber => {\n            const { context } = params;\n            let { subject } = params;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = params.subject = new AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        const err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                            return;\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { params, subscriber, context });\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    const { params, subscriber, context } = state;\n    const { callbackFunc, args, scheduler } = params;\n    let subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        const handler = (...innerArgs) => {\n            const err = innerArgs.shift();\n            if (err) {\n                this.add(scheduler.schedule(dispatchError, 0, { err, subject }));\n            }\n            else {\n                const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n            }\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            this.add(scheduler.schedule(dispatchError, 0, { err, subject }));\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    const { value, subject } = arg;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    const { err, subject } = arg;\n    subject.error(err);\n}\n","import { root } from '../../util/root';\nimport { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { map } from '../../operators/map';\nfunction getCORSRequest() {\n    if (root.XMLHttpRequest) {\n        return new root.XMLHttpRequest();\n    }\n    else if (!!root.XDomainRequest) {\n        return new root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root.XMLHttpRequest) {\n        return new root.XMLHttpRequest();\n    }\n    else {\n        let progId;\n        try {\n            const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (let i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nexport function ajaxGet(url, headers = null) {\n    return new AjaxObservable({ method: 'GET', url, headers });\n}\nexport function ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url, body, headers });\n}\nexport function ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url, headers });\n}\nexport function ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url, body, headers });\n}\nexport function ajaxPatch(url, body, headers) {\n    return new AjaxObservable({ method: 'PATCH', url, body, headers });\n}\nconst mapResponse = map((x, index) => x.response);\nexport function ajaxGetJSON(url, headers) {\n    return mapResponse(new AjaxObservable({\n        method: 'GET',\n        url,\n        responseType: 'json',\n        headers\n    }));\n}\nexport class AjaxObservable extends Observable {\n    constructor(urlOrRequest) {\n        super();\n        const request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest() : getXMLHttpRequest();\n            },\n            crossDomain: true,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (const prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    _subscribe(subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    }\n}\nAjaxObservable.create = (() => {\n    const create = (urlOrRequest) => {\n        return new AjaxObservable(urlOrRequest);\n    };\n    create.get = ajaxGet;\n    create.post = ajaxPost;\n    create.delete = ajaxDelete;\n    create.put = ajaxPut;\n    create.patch = ajaxPatch;\n    create.getJSON = ajaxGetJSON;\n    return create;\n})();\nexport class AjaxSubscriber extends Subscriber {\n    constructor(destination, request) {\n        super(destination);\n        this.request = request;\n        this.done = false;\n        const headers = request.headers = request.headers || {};\n        if (!request.crossDomain && !this.getHeader(headers, 'X-Requested-With')) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        let contentTypeHeader = this.getHeader(headers, 'Content-Type');\n        if (!contentTypeHeader && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        request.body = this.serializeBody(request.body, this.getHeader(request.headers, 'Content-Type'));\n        this.send();\n    }\n    next(e) {\n        this.done = true;\n        const { xhr, request, destination } = this;\n        let result;\n        try {\n            result = new AjaxResponse(e, xhr, request);\n        }\n        catch (err) {\n            return destination.error(err);\n        }\n        destination.next(result);\n    }\n    send() {\n        const { request, request: { user, method, url, async, password, headers, body } } = this;\n        try {\n            const xhr = this.xhr = request.createXHR();\n            this.setupEvents(xhr, request);\n            if (user) {\n                xhr.open(method, url, async, user, password);\n            }\n            else {\n                xhr.open(method, url, async);\n            }\n            if (async) {\n                xhr.timeout = request.timeout;\n                xhr.responseType = request.responseType;\n            }\n            if ('withCredentials' in xhr) {\n                xhr.withCredentials = !!request.withCredentials;\n            }\n            this.setHeaders(xhr, headers);\n            if (body) {\n                xhr.send(body);\n            }\n            else {\n                xhr.send();\n            }\n        }\n        catch (err) {\n            this.error(err);\n        }\n    }\n    serializeBody(body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root.FormData && body instanceof root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            const splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(body[key])}`).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    }\n    setHeaders(xhr, headers) {\n        for (let key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    }\n    getHeader(headers, headerName) {\n        for (let key in headers) {\n            if (key.toLowerCase() === headerName.toLowerCase()) {\n                return headers[key];\n            }\n        }\n        return undefined;\n    }\n    setupEvents(xhr, request) {\n        const progressSubscriber = request.progressSubscriber;\n        function xhrTimeout(e) {\n            const { subscriber, progressSubscriber, request } = xhrTimeout;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            let error;\n            try {\n                error = new AjaxTimeoutError(this, request);\n            }\n            catch (err) {\n                error = err;\n            }\n            subscriber.error(error);\n        }\n        xhr.ontimeout = xhrTimeout;\n        xhrTimeout.request = request;\n        xhrTimeout.subscriber = this;\n        xhrTimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr) {\n            if (progressSubscriber) {\n                let xhrProgress;\n                xhrProgress = function (e) {\n                    const { progressSubscriber } = xhrProgress;\n                    progressSubscriber.next(e);\n                };\n                if (root.XDomainRequest) {\n                    xhr.onprogress = xhrProgress;\n                }\n                else {\n                    xhr.upload.onprogress = xhrProgress;\n                }\n                xhrProgress.progressSubscriber = progressSubscriber;\n            }\n            let xhrError;\n            xhrError = function (e) {\n                const { progressSubscriber, subscriber, request } = xhrError;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                let error;\n                try {\n                    error = new AjaxError('ajax error', this, request);\n                }\n                catch (err) {\n                    error = err;\n                }\n                subscriber.error(error);\n            };\n            xhr.onerror = xhrError;\n            xhrError.request = request;\n            xhrError.subscriber = this;\n            xhrError.progressSubscriber = progressSubscriber;\n        }\n        function xhrReadyStateChange(e) {\n            return;\n        }\n        xhr.onreadystatechange = xhrReadyStateChange;\n        xhrReadyStateChange.subscriber = this;\n        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n        xhrReadyStateChange.request = request;\n        function xhrLoad(e) {\n            const { subscriber, progressSubscriber, request } = xhrLoad;\n            if (this.readyState === 4) {\n                let status = this.status === 1223 ? 204 : this.status;\n                let response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                if (status === 0) {\n                    status = response ? 200 : 0;\n                }\n                if (status < 400) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    let error;\n                    try {\n                        error = new AjaxError('ajax error ' + status, this, request);\n                    }\n                    catch (err) {\n                        error = err;\n                    }\n                    subscriber.error(error);\n                }\n            }\n        }\n        xhr.onload = xhrLoad;\n        xhrLoad.subscriber = this;\n        xhrLoad.progressSubscriber = progressSubscriber;\n        xhrLoad.request = request;\n    }\n    unsubscribe() {\n        const { done, xhr } = this;\n        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n            xhr.abort();\n        }\n        super.unsubscribe();\n    }\n}\nexport class AjaxResponse {\n    constructor(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        this.response = parseXhrResponse(this.responseType, xhr);\n    }\n}\nconst AjaxErrorImpl = (() => {\n    function AjaxErrorImpl(message, xhr, request) {\n        Error.call(this);\n        this.message = message;\n        this.name = 'AjaxError';\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        this.response = parseXhrResponse(this.responseType, xhr);\n        return this;\n    }\n    AjaxErrorImpl.prototype = Object.create(Error.prototype);\n    return AjaxErrorImpl;\n})();\nexport const AjaxError = AjaxErrorImpl;\nfunction parseJson(xhr) {\n    if ('response' in xhr) {\n        return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n    }\n    else {\n        return JSON.parse(xhr.responseText || 'null');\n    }\n}\nfunction parseXhrResponse(responseType, xhr) {\n    switch (responseType) {\n        case 'json':\n            return parseJson(xhr);\n        case 'xml':\n            return xhr.responseXML;\n        case 'text':\n        default:\n            return ('response' in xhr) ? xhr.response : xhr.responseText;\n    }\n}\nfunction AjaxTimeoutErrorImpl(xhr, request) {\n    AjaxError.call(this, 'ajax timeout', xhr, request);\n    this.name = 'AjaxTimeoutError';\n    return this;\n}\nexport const AjaxTimeoutError = AjaxTimeoutErrorImpl;\n","import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nconst DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: (e) => JSON.parse(e.data),\n    serializer: (value) => JSON.stringify(value),\n};\nconst WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nexport class WebSocketSubject extends AnonymousSubject {\n    constructor(urlConfigOrSource, destination) {\n        super();\n        if (urlConfigOrSource instanceof Observable) {\n            this.destination = destination;\n            this.source = urlConfigOrSource;\n        }\n        else {\n            const config = this._config = Object.assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (let key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject();\n        }\n    }\n    lift(operator) {\n        const sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    }\n    _resetState() {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    }\n    multiplex(subMsg, unsubMsg, messageFilter) {\n        const self = this;\n        return new Observable((observer) => {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            const subscription = self.subscribe(x => {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, err => observer.error(err), () => observer.complete());\n            return () => {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    }\n    _connectSocket() {\n        const { WebSocketCtor, protocol, url, binaryType } = this._config;\n        const observer = this._output;\n        let socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        const subscription = new Subscription(() => {\n            this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = (e) => {\n            const { _socket } = this;\n            if (!_socket) {\n                socket.close();\n                this._resetState();\n                return;\n            }\n            const { openObserver } = this._config;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            const queue = this.destination;\n            this.destination = Subscriber.create((x) => {\n                if (socket.readyState === 1) {\n                    try {\n                        const { serializer } = this._config;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        this.destination.error(e);\n                    }\n                }\n            }, (e) => {\n                const { closingObserver } = this._config;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                this._resetState();\n            }, () => {\n                const { closingObserver } = this._config;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(this.destination));\n            }\n        };\n        socket.onerror = (e) => {\n            this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = (e) => {\n            this._resetState();\n            const { closeObserver } = this._config;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = (e) => {\n            try {\n                const { deserializer } = this._config;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    }\n    _subscribe(subscriber) {\n        const { source } = this;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(() => {\n            const { _socket } = this;\n            if (this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                this._resetState();\n            }\n        });\n        return subscriber;\n    }\n    unsubscribe() {\n        const { _socket } = this;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        super.unsubscribe();\n    }\n}\n","import { AjaxObservable } from './AjaxObservable';\nexport const ajax = (() => AjaxObservable.create)();\n","import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nconst toString = (() => Object.prototype.toString)();\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable(subscriber => {\n        function handler(e) {\n            if (arguments.length > 1) {\n                subscriber.next(Array.prototype.slice.call(arguments));\n            }\n            else {\n                subscriber.next(e);\n            }\n        }\n        setupSubscription(target, eventName, handler, subscriber, options);\n    });\n}\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n    let unsubscribe;\n    if (isEventTarget(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addEventListener(eventName, handler, options);\n        unsubscribe = () => source.removeEventListener(eventName, handler, options);\n    }\n    else if (isJQueryStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.on(eventName, handler);\n        unsubscribe = () => source.off(eventName, handler);\n    }\n    else if (isNodeStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addListener(eventName, handler);\n        unsubscribe = () => source.removeListener(eventName, handler);\n    }\n    else if (sourceObj && sourceObj.length) {\n        for (let i = 0, len = sourceObj.length; i < len; i++) {\n            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n        }\n    }\n    else {\n        throw new TypeError('Invalid event target');\n    }\n    subscriber.add(unsubscribe);\n}\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isEventTarget(sourceObj) {\n    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nexport function fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(map(args => isArray(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable(subscriber => {\n        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);\n        let retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!isFunction(removeHandler)) {\n            return undefined;\n        }\n        return () => removeHandler(handler, retValue);\n    });\n}\n","import { Observable } from '../Observable';\nimport { subscribeToIterable } from '../util/subscribeToIterable';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\nexport function fromIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    if (!scheduler) {\n        return new Observable(subscribeToIterable(input));\n    }\n    else {\n        return scheduleIterable(input, scheduler);\n    }\n}\n","import { Observable } from '../Observable';\nimport { subscribeToPromise } from '../util/subscribeToPromise';\nimport { schedulePromise } from '../scheduled/schedulePromise';\nexport function fromPromise(input, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscribeToPromise(input));\n    }\n    else {\n        return schedulePromise(input, scheduler);\n    }\n}\n","import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    let resultSelector;\n    let initialState;\n    if (arguments.length == 1) {\n        const options = initialStateOrOptions;\n        initialState = options.initialState;\n        condition = options.condition;\n        iterate = options.iterate;\n        resultSelector = options.resultSelector || identity;\n        scheduler = options.scheduler;\n    }\n    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n        initialState = initialStateOrOptions;\n        resultSelector = identity;\n        scheduler = resultSelectorOrObservable;\n    }\n    else {\n        initialState = initialStateOrOptions;\n        resultSelector = resultSelectorOrObservable;\n    }\n    return new Observable(subscriber => {\n        let state = initialState;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                subscriber,\n                iterate,\n                condition,\n                resultSelector,\n                state\n            });\n        }\n        do {\n            if (condition) {\n                let conditionResult;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return undefined;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            let value;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n        } while (true);\n        return undefined;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, condition } = state;\n    if (subscriber.closed) {\n        return undefined;\n    }\n    if (state.needIterate) {\n        try {\n            state.state = state.iterate(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n    }\n    else {\n        state.needIterate = true;\n    }\n    if (condition) {\n        let conditionResult;\n        try {\n            conditionResult = condition(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!conditionResult) {\n            subscriber.complete();\n            return undefined;\n        }\n        if (subscriber.closed) {\n            return undefined;\n        }\n    }\n    let value;\n    try {\n        value = state.resultSelector(state.state);\n    }\n    catch (err) {\n        subscriber.error(err);\n        return undefined;\n    }\n    if (subscriber.closed) {\n        return undefined;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n        return undefined;\n    }\n    return this.schedule(state);\n}\n","import { defer } from './defer';\nimport { EMPTY } from './empty';\nexport function iif(condition, trueResult = EMPTY, falseResult = EMPTY) {\n    return defer(() => condition() ? trueResult : falseResult);\n}\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period = 0, scheduler = async) {\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(subscriber => {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, counter, period } = state;\n    subscriber.next(counter);\n    this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\nexport const NEVER = new Observable(noop);\nexport function never() {\n    return NEVER;\n}\n","import { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nexport function onErrorResumeNext(...sources) {\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    const [first, ...remainder] = sources;\n    if (sources.length === 1 && isArray(first)) {\n        return onErrorResumeNext(...first);\n    }\n    return new Observable(subscriber => {\n        const subNext = () => subscriber.add(onErrorResumeNext(...remainder).subscribe(subscriber));\n        return from(first).subscribe({\n            next(value) { subscriber.next(value); },\n            error: subNext,\n            complete: subNext,\n        });\n    });\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function pairs(obj, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscriber => {\n            const keys = Object.keys(obj);\n            for (let i = 0; i < keys.length && !subscriber.closed; i++) {\n                const key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    subscriber.next([key, obj[key]]);\n                }\n            }\n            subscriber.complete();\n        });\n    }\n    else {\n        return new Observable(subscriber => {\n            const keys = Object.keys(obj);\n            const subscription = new Subscription();\n            subscription.add(scheduler.schedule(dispatch, 0, { keys, index: 0, subscriber, subscription, obj }));\n            return subscription;\n        });\n    }\n}\nexport function dispatch(state) {\n    const { keys, index, subscriber, subscription, obj } = state;\n    if (!subscriber.closed) {\n        if (index < keys.length) {\n            const key = keys[index];\n            subscriber.next([key, obj[key]]);\n            subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));\n        }\n        else {\n            subscriber.complete();\n        }\n    }\n}\n","import { not } from '../util/not';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { filter } from '../operators/filter';\nimport { Observable } from '../Observable';\nexport function partition(source, predicate, thisArg) {\n    return [\n        filter(predicate, thisArg)(new Observable(subscribeTo(source))),\n        filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))\n    ];\n}\n","import { isArray } from '../util/isArray';\nimport { fromArray } from './fromArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function race(...observables) {\n    if (observables.length === 1) {\n        if (isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return fromArray(observables, undefined).lift(new RaceOperator());\n}\nexport class RaceOperator {\n    call(subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    }\n}\nexport class RaceSubscriber extends OuterSubscriber {\n    constructor(destination) {\n        super(destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    _next(observable) {\n        this.observables.push(observable);\n    }\n    _complete() {\n        const observables = this.observables;\n        const len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (let i = 0; i < len && !this.hasFirst; i++) {\n                const observable = observables[i];\n                const subscription = subscribeToResult(this, observable, undefined, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    }\n    notifyNext(_outerValue, innerValue, outerIndex) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (let i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    let subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    }\n}\n","import { Observable } from '../Observable';\nexport function range(start = 0, count, scheduler) {\n    return new Observable(subscriber => {\n        if (count === undefined) {\n            count = start;\n            start = 0;\n        }\n        let index = 0;\n        let current = start;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                index, count, start, subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(current++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        return undefined;\n    });\n}\nexport function dispatch(state) {\n    const { start, index, count, subscriber } = state;\n    if (index >= count) {\n        subscriber.complete();\n        return;\n    }\n    subscriber.next(start);\n    if (subscriber.closed) {\n        return;\n    }\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n}\n","import { Observable } from '../Observable';\nexport function throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscriber => subscriber.error(error));\n    }\n    else {\n        return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n    }\n}\nfunction dispatch({ error, subscriber }) {\n    subscriber.error(error);\n}\n","import { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function timer(dueTime = 0, periodOrScheduler, scheduler) {\n    let period = -1;\n    if (isNumeric(periodOrScheduler)) {\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n    }\n    else if (isScheduler(periodOrScheduler)) {\n        scheduler = periodOrScheduler;\n    }\n    if (!isScheduler(scheduler)) {\n        scheduler = async;\n    }\n    return new Observable(subscriber => {\n        const due = isNumeric(dueTime)\n            ? dueTime\n            : (+dueTime - scheduler.now());\n        return scheduler.schedule(dispatch, due, {\n            index: 0, period, subscriber\n        });\n    });\n}\nfunction dispatch(state) {\n    const { index, period, subscriber } = state;\n    subscriber.next(index);\n    if (subscriber.closed) {\n        return;\n    }\n    else if (period === -1) {\n        return subscriber.complete();\n    }\n    state.index = index + 1;\n    this.schedule(state, period);\n}\n","import { Observable } from '../Observable';\nimport { from } from './from';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n    return new Observable(subscriber => {\n        let resource;\n        try {\n            resource = resourceFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        let result;\n        try {\n            result = observableFactory(resource);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        const source = result ? from(result) : EMPTY;\n        const subscription = source.subscribe(subscriber);\n        return () => {\n            subscription.unsubscribe();\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\n","import { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function zip(...observables) {\n    const resultSelector = observables[observables.length - 1];\n    if (typeof resultSelector === 'function') {\n        observables.pop();\n    }\n    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\nexport class ZipOperator {\n    constructor(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n    }\n}\nexport class ZipSubscriber extends Subscriber {\n    constructor(destination, resultSelector, values = Object.create(null)) {\n        super(destination);\n        this.resultSelector = resultSelector;\n        this.iterators = [];\n        this.active = 0;\n        this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;\n    }\n    _next(value) {\n        const iterators = this.iterators;\n        if (isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[Symbol_iterator] === 'function') {\n            iterators.push(new StaticIterator(value[Symbol_iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    }\n    _complete() {\n        const iterators = this.iterators;\n        const len = iterators.length;\n        this.unsubscribe();\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                const destination = this.destination;\n                destination.add(iterator.subscribe());\n            }\n            else {\n                this.active--;\n            }\n        }\n    }\n    notifyInactive() {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    }\n    checkIterators() {\n        const iterators = this.iterators;\n        const len = iterators.length;\n        const destination = this.destination;\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        let shouldComplete = false;\n        const args = [];\n        for (let i = 0; i < len; i++) {\n            let iterator = iterators[i];\n            let result = iterator.next();\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.resultSelector) {\n            this._tryresultSelector(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    }\n    _tryresultSelector(args) {\n        let result;\n        try {\n            result = this.resultSelector.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\nclass StaticIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    hasValue() {\n        return true;\n    }\n    next() {\n        const result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    }\n    hasCompleted() {\n        const nextResult = this.nextResult;\n        return Boolean(nextResult && nextResult.done);\n    }\n}\nclass StaticArrayIterator {\n    constructor(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    [Symbol_iterator]() {\n        return this;\n    }\n    next(value) {\n        const i = this.index++;\n        const array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    }\n    hasValue() {\n        return this.array.length > this.index;\n    }\n    hasCompleted() {\n        return this.array.length === this.index;\n    }\n}\nclass ZipBufferIterator extends SimpleOuterSubscriber {\n    constructor(destination, parent, observable) {\n        super(destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    [Symbol_iterator]() {\n        return this;\n    }\n    next() {\n        const buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    }\n    hasValue() {\n        return this.buffer.length > 0;\n    }\n    hasCompleted() {\n        return this.buffer.length === 0 && this.isComplete;\n    }\n    notifyComplete() {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    }\n    notifyNext(innerValue) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    }\n    subscribe() {\n        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nclass AuditOperator {\n    constructor(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    }\n}\nclass AuditSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, durationSelector) {\n        super(destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            let duration;\n            try {\n                const { durationSelector } = this;\n                duration = durationSelector(value);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n            const innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n            if (!innerSubscription || innerSubscription.closed) {\n                this.clearThrottle();\n            }\n            else {\n                this.add(this.throttled = innerSubscription);\n            }\n        }\n    }\n    clearThrottle() {\n        const { value, hasValue, throttled } = this;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = undefined;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = undefined;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    }\n    notifyNext() {\n        this.clearThrottle();\n    }\n    notifyComplete() {\n        this.clearThrottle();\n    }\n}\n","import { async } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nexport function auditTime(duration, scheduler = async) {\n    return audit(() => timer(duration, scheduler));\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nclass BufferOperator {\n    constructor(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    }\n}\nclass BufferSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, closingNotifier) {\n        super(destination);\n        this.buffer = [];\n        this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n    }\n    _next(value) {\n        this.buffer.push(value);\n    }\n    notifyNext() {\n        const buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function bufferCount(bufferSize, startBufferEvery = null) {\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nclass BufferCountOperator {\n    constructor(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    call(subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    }\n}\nclass BufferCountSubscriber extends Subscriber {\n    constructor(destination, bufferSize) {\n        super(destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    _next(value) {\n        const buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    }\n    _complete() {\n        const buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        super._complete();\n    }\n}\nclass BufferSkipCountSubscriber extends Subscriber {\n    constructor(destination, bufferSize, startBufferEvery) {\n        super(destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    _next(value) {\n        const { bufferSize, startBufferEvery, buffers, count } = this;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (let i = buffers.length; i--;) {\n            const buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    }\n    _complete() {\n        const { buffers, destination } = this;\n        while (buffers.length > 0) {\n            let buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        super._complete();\n    }\n}\n","import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    let length = arguments.length;\n    let scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    let bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    let maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nclass BufferTimeOperator {\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n}\nclass Context {\n    constructor() {\n        this.buffer = [];\n    }\n}\nclass BufferTimeSubscriber extends Subscriber {\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        super(destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        const context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            const closeState = { subscriber: this, context };\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        let filledBufferContext;\n        for (let i = 0; i < len; i++) {\n            const context = contexts[i];\n            const buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    }\n    _error(err) {\n        this.contexts.length = 0;\n        super._error(err);\n    }\n    _complete() {\n        const { contexts, destination } = this;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.contexts = null;\n    }\n    onBufferFull(context) {\n        this.closeContext(context);\n        const closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            const bufferTimeSpan = this.bufferTimeSpan;\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    }\n    openContext() {\n        const context = new Context();\n        this.contexts.push(context);\n        return context;\n    }\n    closeContext(context) {\n        this.destination.next(context.buffer);\n        const contexts = this.contexts;\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n    const subscriber = state.subscriber;\n    const prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n    const context = subscriber.openContext();\n    const action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    const { subscriber, context } = arg;\n    subscriber.closeContext(context);\n}\n","import { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nexport function bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nclass BufferToggleOperator {\n    constructor(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    }\n}\nclass BufferToggleSubscriber extends OuterSubscriber {\n    constructor(destination, openings, closingSelector) {\n        super(destination);\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult(this, openings));\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        for (let i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    }\n    _error(err) {\n        const contexts = this.contexts;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        super._error(err);\n    }\n    _complete() {\n        const contexts = this.contexts;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        super._complete();\n    }\n    notifyNext(outerValue, innerValue) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    }\n    notifyComplete(innerSub) {\n        this.closeBuffer(innerSub.context);\n    }\n    openBuffer(value) {\n        try {\n            const closingSelector = this.closingSelector;\n            const closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    }\n    closeBuffer(context) {\n        const contexts = this.contexts;\n        if (contexts && context) {\n            const { buffer, subscription } = context;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    }\n    trySubscribe(closingNotifier) {\n        const contexts = this.contexts;\n        const buffer = [];\n        const subscription = new Subscription();\n        const context = { buffer, subscription };\n        contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    }\n}\n","import { Subscription } from '../Subscription';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nclass BufferWhenOperator {\n    constructor(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    }\n}\nclass BufferWhenSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, closingSelector) {\n        super(destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    _next(value) {\n        this.buffer.push(value);\n    }\n    _complete() {\n        const buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.buffer = undefined;\n        this.subscribing = false;\n    }\n    notifyNext() {\n        this.openBuffer();\n    }\n    notifyComplete() {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    }\n    openBuffer() {\n        let { closingSubscription } = this;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        const buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        let closingNotifier;\n        try {\n            const { closingSelector } = this;\n            closingNotifier = closingSelector();\n        }\n        catch (err) {\n            return this.error(err);\n        }\n        closingSubscription = new Subscription();\n        this.closingSubscription = closingSubscription;\n        this.add(closingSubscription);\n        this.subscribing = true;\n        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n        this.subscribing = false;\n    }\n}\n","import { CombineLatestOperator } from '../observable/combineLatest';\nexport function combineAll(project) {\n    return (source) => source.lift(new CombineLatestOperator(project));\n}\n","import { isArray } from '../util/isArray';\nimport { CombineLatestOperator } from '../observable/combineLatest';\nimport { from } from '../observable/from';\nconst none = {};\nexport function combineLatest(...observables) {\n    let project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    if (observables.length === 1 && isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return (source) => source.lift.call(from([source, ...observables]), new CombineLatestOperator(project));\n}\n","import { concat as concatStatic } from '../observable/concat';\nexport function concat(...observables) {\n    return (source) => source.lift.call(concatStatic(source, ...observables));\n}\n","import { concatMap } from './concatMap';\nexport function concatMapTo(innerObservable, resultSelector) {\n    return concatMap(() => innerObservable, resultSelector);\n}\n","import { Subscriber } from '../Subscriber';\nexport function count(predicate) {\n    return (source) => source.lift(new CountOperator(predicate, source));\n}\nclass CountOperator {\n    constructor(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    }\n}\nclass CountSubscriber extends Subscriber {\n    constructor(destination, predicate, source) {\n        super(destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    _next(value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    }\n    _tryPredicate(value) {\n        let result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    }\n    _complete() {\n        this.destination.next(this.count);\n        this.destination.complete();\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function debounce(durationSelector) {\n    return (source) => source.lift(new DebounceOperator(durationSelector));\n}\nclass DebounceOperator {\n    constructor(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    }\n}\nclass DebounceSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, durationSelector) {\n        super(destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    _next(value) {\n        try {\n            const result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        this.emitValue();\n        this.destination.complete();\n    }\n    _tryNext(value, duration) {\n        let subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n        if (subscription && !subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    }\n    notifyNext() {\n        this.emitValue();\n    }\n    notifyComplete() {\n        this.emitValue();\n    }\n    emitValue() {\n        if (this.hasValue) {\n            const value = this.value;\n            const subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = undefined;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = undefined;\n            this.hasValue = false;\n            super._next(value);\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function debounceTime(dueTime, scheduler = async) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass DebounceTimeSubscriber extends Subscriber {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function delay(delay, scheduler = async) {\n    const absoluteDelay = isDate(delay);\n    const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return (source) => source.lift(new DelayOperator(delayFor, scheduler));\n}\nclass DelayOperator {\n    constructor(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    }\n}\nclass DelaySubscriber extends Subscriber {\n    constructor(destination, delay, scheduler) {\n        super(destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    static dispatch(state) {\n        const source = state.source;\n        const queue = source.queue;\n        const scheduler = state.scheduler;\n        const destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            const delay = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay);\n        }\n        else {\n            this.unsubscribe();\n            source.active = false;\n        }\n    }\n    _schedule(scheduler) {\n        this.active = true;\n        const destination = this.destination;\n        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    }\n    scheduleNotification(notification) {\n        if (this.errored === true) {\n            return;\n        }\n        const scheduler = this.scheduler;\n        const message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    }\n    _next(value) {\n        this.scheduleNotification(Notification.createNext(value));\n    }\n    _error(err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n        this.unsubscribe();\n    }\n    _complete() {\n        this.scheduleNotification(Notification.createComplete());\n        this.unsubscribe();\n    }\n}\nclass DelayMessage {\n    constructor(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return (source) => new SubscriptionDelayObservable(source, subscriptionDelay)\n            .lift(new DelayWhenOperator(delayDurationSelector));\n    }\n    return (source) => source.lift(new DelayWhenOperator(delayDurationSelector));\n}\nclass DelayWhenOperator {\n    constructor(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    }\n}\nclass DelayWhenSubscriber extends OuterSubscriber {\n    constructor(destination, delayDurationSelector) {\n        super(destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.index = 0;\n    }\n    notifyNext(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    }\n    notifyError(error, innerSub) {\n        this._error(error);\n    }\n    notifyComplete(innerSub) {\n        const value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    }\n    _next(value) {\n        const index = this.index++;\n        try {\n            const delayNotifier = this.delayDurationSelector(value, index);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        this.completed = true;\n        this.tryComplete();\n        this.unsubscribe();\n    }\n    removeSubscription(subscription) {\n        subscription.unsubscribe();\n        const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        if (subscriptionIdx !== -1) {\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n        }\n        return subscription.outerValue;\n    }\n    tryDelay(delayNotifier, value) {\n        const notifierSubscription = subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            const destination = this.destination;\n            destination.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n    }\n    tryComplete() {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    }\n}\nclass SubscriptionDelayObservable extends Observable {\n    constructor(source, subscriptionDelay) {\n        super();\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    _subscribe(subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    }\n}\nclass SubscriptionDelaySubscriber extends Subscriber {\n    constructor(parent, source) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    _next(unused) {\n        this.subscribeToSource();\n    }\n    _error(err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    }\n    _complete() {\n        this.unsubscribe();\n        this.subscribeToSource();\n    }\n    subscribeToSource() {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nclass DeMaterializeOperator {\n    call(subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    }\n}\nclass DeMaterializeSubscriber extends Subscriber {\n    constructor(destination) {\n        super(destination);\n    }\n    _next(value) {\n        value.observe(this.destination);\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function distinct(keySelector, flushes) {\n    return (source) => source.lift(new DistinctOperator(keySelector, flushes));\n}\nclass DistinctOperator {\n    constructor(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    }\n}\nexport class DistinctSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, keySelector, flushes) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.values = new Set();\n        if (flushes) {\n            this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(this)));\n        }\n    }\n    notifyNext() {\n        this.values.clear();\n    }\n    notifyError(error) {\n        this._error(error);\n    }\n    _next(value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    }\n    _useKeySelector(value) {\n        let key;\n        const { destination } = this;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    }\n    _finalizeNext(key, value) {\n        const { values } = this;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    }\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nexport function distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged((x, y) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n","import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\nexport function elementAt(index, defaultValue) {\n    if (index < 0) {\n        throw new ArgumentOutOfRangeError();\n    }\n    const hasDefaultValue = arguments.length >= 2;\n    return (source) => source.pipe(filter((v, i) => i === index), take(1), hasDefaultValue\n        ? defaultIfEmpty(defaultValue)\n        : throwIfEmpty(() => new ArgumentOutOfRangeError()));\n}\n","import { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nexport function endWith(...array) {\n    return (source) => concat(source, of(...array));\n}\n","import { Subscriber } from '../Subscriber';\nexport function every(predicate, thisArg) {\n    return (source) => source.lift(new EveryOperator(predicate, thisArg, source));\n}\nclass EveryOperator {\n    constructor(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    call(observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    }\n}\nclass EverySubscriber extends Subscriber {\n    constructor(destination, predicate, thisArg, source) {\n        super(destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    notifyComplete(everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    }\n    _next(value) {\n        let result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    }\n    _complete() {\n        this.notifyComplete(true);\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function exhaust() {\n    return (source) => source.lift(new SwitchFirstOperator());\n}\nclass SwitchFirstOperator {\n    call(subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    }\n}\nclass SwitchFirstSubscriber extends SimpleOuterSubscriber {\n    constructor(destination) {\n        super(destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    _next(value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n        }\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    }\n    notifyComplete() {\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    }\n}\n","import { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function exhaustMap(project, resultSelector) {\n    if (resultSelector) {\n        return (source) => source.pipe(exhaustMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii)))));\n    }\n    return (source) => source.lift(new ExhaustMapOperator(project));\n}\nclass ExhaustMapOperator {\n    constructor(project) {\n        this.project = project;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));\n    }\n}\nclass ExhaustMapSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, project) {\n        super(destination);\n        this.project = project;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    _next(value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    }\n    tryNext(value) {\n        let result;\n        const index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.hasSubscription = true;\n        this._innerSub(result);\n    }\n    _innerSub(result) {\n        const innerSubscriber = new SimpleInnerSubscriber(this);\n        const destination = this.destination;\n        destination.add(innerSubscriber);\n        const innerSubscription = innerSubscribe(result, innerSubscriber);\n        if (innerSubscription !== innerSubscriber) {\n            destination.add(innerSubscription);\n        }\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    }\n    notifyNext(innerValue) {\n        this.destination.next(innerValue);\n    }\n    notifyError(err) {\n        this.destination.error(err);\n    }\n    notifyComplete() {\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler) {\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return (source) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n    constructor(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    }\n}\nexport class ExpandSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, project, concurrent, scheduler) {\n        super(destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    static dispatch(arg) {\n        const { subscriber, result, value, index } = arg;\n        subscriber.subscribeToProjection(result, value, index);\n    }\n    _next(value) {\n        const destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        const index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            try {\n                const { project } = this;\n                const result = project(value, index);\n                if (!this.scheduler) {\n                    this.subscribeToProjection(result, value, index);\n                }\n                else {\n                    const state = { subscriber: this, result, value, index };\n                    const destination = this.destination;\n                    destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n                }\n            }\n            catch (e) {\n                destination.error(e);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    }\n    subscribeToProjection(result, value, index) {\n        this.active++;\n        const destination = this.destination;\n        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    }\n    notifyNext(innerValue) {\n        this._next(innerValue);\n    }\n    notifyComplete() {\n        const buffer = this.buffer;\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return (source) => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\nexport class FindValueOperator {\n    constructor(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    call(observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    }\n}\nexport class FindValueSubscriber extends Subscriber {\n    constructor(destination, predicate, source, yieldIndex, thisArg) {\n        super(destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    notifyComplete(value) {\n        const destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.unsubscribe();\n    }\n    _next(value) {\n        const { predicate, thisArg } = this;\n        const index = this.index++;\n        try {\n            const result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    }\n}\n","import { FindValueOperator } from '../operators/find';\nexport function findIndex(predicate, thisArg) {\n    return (source) => source.lift(new FindValueOperator(predicate, source, true, thisArg));\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return (source) => source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\nclass GroupByOperator {\n    constructor(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    }\n}\nclass GroupBySubscriber extends Subscriber {\n    constructor(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    _next(value) {\n        let key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    }\n    _group(value, key) {\n        let groups = this.groups;\n        if (!groups) {\n            groups = this.groups = new Map();\n        }\n        let group = groups.get(key);\n        let element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject());\n            groups.set(key, group);\n            const groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                let duration;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    }\n    _error(err) {\n        const groups = this.groups;\n        if (groups) {\n            groups.forEach((group, key) => {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const groups = this.groups;\n        if (groups) {\n            groups.forEach((group, key) => {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    }\n    removeGroup(key) {\n        this.groups.delete(key);\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                super.unsubscribe();\n            }\n        }\n    }\n}\nclass GroupDurationSubscriber extends Subscriber {\n    constructor(key, group, parent) {\n        super(group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    _next(value) {\n        this.complete();\n    }\n    _unsubscribe() {\n        const { parent, key } = this;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    }\n}\nexport class GroupedObservable extends Observable {\n    constructor(key, groupSubject, refCountSubscription) {\n        super();\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    _subscribe(subscriber) {\n        const subscription = new Subscription();\n        const { refCountSubscription, groupSubject } = this;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    }\n}\nclass InnerRefCountSubscription extends Subscription {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        parent.count++;\n    }\n    unsubscribe() {\n        const parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            super.unsubscribe();\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nclass IgnoreElementsOperator {\n    call(subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    }\n}\nclass IgnoreElementsSubscriber extends Subscriber {\n    _next(unused) {\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function isEmpty() {\n    return (source) => source.lift(new IsEmptyOperator());\n}\nclass IsEmptyOperator {\n    call(observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    }\n}\nclass IsEmptySubscriber extends Subscriber {\n    constructor(destination) {\n        super(destination);\n    }\n    notifyComplete(isEmpty) {\n        const destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    }\n    _next(value) {\n        this.notifyComplete(false);\n    }\n    _complete() {\n        this.notifyComplete(true);\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function mapTo(value) {\n    return (source) => source.lift(new MapToOperator(value));\n}\nclass MapToOperator {\n    constructor(value) {\n        this.value = value;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    }\n}\nclass MapToSubscriber extends Subscriber {\n    constructor(destination, value) {\n        super(destination);\n        this.value = value;\n    }\n    _next(x) {\n        this.destination.next(this.value);\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nclass MaterializeOperator {\n    call(subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    }\n}\nclass MaterializeSubscriber extends Subscriber {\n    constructor(destination) {\n        super(destination);\n    }\n    _next(value) {\n        this.destination.next(Notification.createNext(value));\n    }\n    _error(err) {\n        const destination = this.destination;\n        destination.next(Notification.createError(err));\n        destination.complete();\n    }\n    _complete() {\n        const destination = this.destination;\n        destination.next(Notification.createComplete());\n        destination.complete();\n    }\n}\n","import { reduce } from './reduce';\nexport function max(comparer) {\n    const max = (typeof comparer === 'function')\n        ? (x, y) => comparer(x, y) > 0 ? x : y\n        : (x, y) => x > y ? x : y;\n    return reduce(max);\n}\n","import { merge as mergeStatic } from '../observable/merge';\nexport function merge(...observables) {\n    return (source) => source.lift.call(mergeStatic(source, ...observables));\n}\n","import { mergeMap } from './mergeMap';\nexport function mergeMapTo(innerObservable, resultSelector, concurrent = Number.POSITIVE_INFINITY) {\n    if (typeof resultSelector === 'function') {\n        return mergeMap(() => innerObservable, resultSelector, concurrent);\n    }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return mergeMap(() => innerObservable, concurrent);\n}\n","import { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function mergeScan(accumulator, seed, concurrent = Number.POSITIVE_INFINITY) {\n    return (source) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\nexport class MergeScanOperator {\n    constructor(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    }\n}\nexport class MergeScanSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, accumulator, acc, concurrent) {\n        super(destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    _next(value) {\n        if (this.active < this.concurrent) {\n            const index = this.index++;\n            const destination = this.destination;\n            let ish;\n            try {\n                const { accumulator } = this;\n                ish = accumulator(this.acc, value, index);\n            }\n            catch (e) {\n                return destination.error(e);\n            }\n            this.active++;\n            this._innerSub(ish);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    }\n    _innerSub(ish) {\n        const innerSubscriber = new SimpleInnerSubscriber(this);\n        const destination = this.destination;\n        destination.add(innerSubscriber);\n        const innerSubscription = innerSubscribe(ish, innerSubscriber);\n        if (innerSubscription !== innerSubscriber) {\n            destination.add(innerSubscription);\n        }\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    }\n    notifyNext(innerValue) {\n        const { destination } = this;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    }\n    notifyComplete() {\n        const buffer = this.buffer;\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    }\n}\n","import { reduce } from './reduce';\nexport function min(comparer) {\n    const min = (typeof comparer === 'function')\n        ? (x, y) => comparer(x, y) < 0 ? x : y\n        : (x, y) => x < y ? x : y;\n    return reduce(min);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function observeOn(scheduler, delay = 0) {\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nexport class ObserveOnOperator {\n    constructor(scheduler, delay = 0) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    }\n}\nexport class ObserveOnSubscriber extends Subscriber {\n    constructor(destination, scheduler, delay = 0) {\n        super(destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    static dispatch(arg) {\n        const { notification, destination } = arg;\n        notification.observe(destination);\n        this.unsubscribe();\n    }\n    scheduleMessage(notification) {\n        const destination = this.destination;\n        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    }\n    _next(value) {\n        this.scheduleMessage(Notification.createNext(value));\n    }\n    _error(err) {\n        this.scheduleMessage(Notification.createError(err));\n        this.unsubscribe();\n    }\n    _complete() {\n        this.scheduleMessage(Notification.createComplete());\n        this.unsubscribe();\n    }\n}\nexport class ObserveOnMessage {\n    constructor(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n}\n","import { from } from '../observable/from';\nimport { isArray } from '../util/isArray';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function onErrorResumeNext(...nextSources) {\n    if (nextSources.length === 1 && isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return (source) => source.lift(new OnErrorResumeNextOperator(nextSources));\n}\nexport function onErrorResumeNextStatic(...nextSources) {\n    let source = undefined;\n    if (nextSources.length === 1 && isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return from(source).lift(new OnErrorResumeNextOperator(nextSources));\n}\nclass OnErrorResumeNextOperator {\n    constructor(nextSources) {\n        this.nextSources = nextSources;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    }\n}\nclass OnErrorResumeNextSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, nextSources) {\n        super(destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    notifyError() {\n        this.subscribeToNextSource();\n    }\n    notifyComplete() {\n        this.subscribeToNextSource();\n    }\n    _error(err) {\n        this.subscribeToNextSource();\n        this.unsubscribe();\n    }\n    _complete() {\n        this.subscribeToNextSource();\n        this.unsubscribe();\n    }\n    subscribeToNextSource() {\n        const next = this.nextSources.shift();\n        if (!!next) {\n            const innerSubscriber = new SimpleInnerSubscriber(this);\n            const destination = this.destination;\n            destination.add(innerSubscriber);\n            const innerSubscription = innerSubscribe(next, innerSubscriber);\n            if (innerSubscription !== innerSubscriber) {\n                destination.add(innerSubscription);\n            }\n        }\n        else {\n            this.destination.complete();\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function pairwise() {\n    return (source) => source.lift(new PairwiseOperator());\n}\nclass PairwiseOperator {\n    call(subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    }\n}\nclass PairwiseSubscriber extends Subscriber {\n    constructor(destination) {\n        super(destination);\n        this.hasPrev = false;\n    }\n    _next(value) {\n        let pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    }\n}\n","import { not } from '../util/not';\nimport { filter } from './filter';\nexport function partition(predicate, thisArg) {\n    return (source) => [\n        filter(predicate, thisArg)(source),\n        filter(not(predicate, thisArg))(source)\n    ];\n}\n","import { map } from './map';\nexport function pluck(...properties) {\n    const length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return (source) => map(plucker(properties, length))(source);\n}\nfunction plucker(props, length) {\n    const mapper = (x) => {\n        let currentProp = x;\n        for (let i = 0; i < length; i++) {\n            const p = currentProp != null ? currentProp[props[i]] : undefined;\n            if (p !== void 0) {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n","import { Subject } from '../Subject';\nimport { multicast } from './multicast';\nexport function publish(selector) {\n    return selector ?\n        multicast(() => new Subject(), selector) :\n        multicast(new Subject());\n}\n","import { BehaviorSubject } from '../BehaviorSubject';\nimport { multicast } from './multicast';\nexport function publishBehavior(value) {\n    return (source) => multicast(new BehaviorSubject(value))(source);\n}\n","import { AsyncSubject } from '../AsyncSubject';\nimport { multicast } from './multicast';\nexport function publishLast() {\n    return (source) => multicast(new AsyncSubject())(source);\n}\n","import { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    const subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n    return (source) => multicast(() => subject, selector)(source);\n}\n","import { isArray } from '../util/isArray';\nimport { race as raceStatic } from '../observable/race';\nexport function race(...observables) {\n    return function raceOperatorFunction(source) {\n        if (observables.length === 1 && isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(raceStatic(source, ...observables));\n    };\n}\n","import { scan } from './scan';\nimport { takeLast } from './takeLast';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { pipe } from '../util/pipe';\nexport function reduce(accumulator, seed) {\n    if (arguments.length >= 2) {\n        return function reduceOperatorFunctionWithSeed(source) {\n            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);\n        };\n    }\n    return function reduceOperatorFunction(source) {\n        return pipe(scan((acc, value, index) => accumulator(acc, value, index + 1)), takeLast(1))(source);\n    };\n}\n","import { Subscriber } from '../Subscriber';\nimport { empty } from '../observable/empty';\nexport function repeat(count = -1) {\n    return (source) => {\n        if (count === 0) {\n            return empty();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nclass RepeatOperator {\n    constructor(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    }\n}\nclass RepeatSubscriber extends Subscriber {\n    constructor(destination, count, source) {\n        super(destination);\n        this.count = count;\n        this.source = source;\n    }\n    complete() {\n        if (!this.isStopped) {\n            const { source, count } = this;\n            if (count === 0) {\n                return super.complete();\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    }\n}\n","import { Subject } from '../Subject';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function repeatWhen(notifier) {\n    return (source) => source.lift(new RepeatWhenOperator(notifier));\n}\nclass RepeatWhenOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    }\n}\nclass RepeatWhenSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, notifier, source) {\n        super(destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    notifyNext() {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    }\n    notifyComplete() {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return super.complete();\n        }\n    }\n    complete() {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            if (!this.retriesSubscription || this.retriesSubscription.closed) {\n                return super.complete();\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next(undefined);\n        }\n    }\n    _unsubscribe() {\n        const { notifications, retriesSubscription } = this;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = undefined;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = undefined;\n        }\n        this.retries = undefined;\n    }\n    _unsubscribeAndRecycle() {\n        const { _unsubscribe } = this;\n        this._unsubscribe = null;\n        super._unsubscribeAndRecycle();\n        this._unsubscribe = _unsubscribe;\n        return this;\n    }\n    subscribeToRetries() {\n        this.notifications = new Subject();\n        let retries;\n        try {\n            const { notifier } = this;\n            retries = notifier(this.notifications);\n        }\n        catch (e) {\n            return super.complete();\n        }\n        this.retries = retries;\n        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function retry(count = -1) {\n    return (source) => source.lift(new RetryOperator(count, source));\n}\nclass RetryOperator {\n    constructor(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    }\n}\nclass RetrySubscriber extends Subscriber {\n    constructor(destination, count, source) {\n        super(destination);\n        this.count = count;\n        this.source = source;\n    }\n    error(err) {\n        if (!this.isStopped) {\n            const { source, count } = this;\n            if (count === 0) {\n                return super.error(err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    }\n}\n","import { Subject } from '../Subject';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function retryWhen(notifier) {\n    return (source) => source.lift(new RetryWhenOperator(notifier, source));\n}\nclass RetryWhenOperator {\n    constructor(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    }\n}\nclass RetryWhenSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, notifier, source) {\n        super(destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    error(err) {\n        if (!this.isStopped) {\n            let errors = this.errors;\n            let retries = this.retries;\n            let retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject();\n                try {\n                    const { notifier } = this;\n                    retries = notifier(errors);\n                }\n                catch (e) {\n                    return super.error(e);\n                }\n                retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n            }\n            else {\n                this.errors = undefined;\n                this.retriesSubscription = undefined;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    }\n    _unsubscribe() {\n        const { errors, retriesSubscription } = this;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = undefined;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = undefined;\n        }\n        this.retries = undefined;\n    }\n    notifyNext() {\n        const { _unsubscribe } = this;\n        this._unsubscribe = null;\n        this._unsubscribeAndRecycle();\n        this._unsubscribe = _unsubscribe;\n        this.source.subscribe(this);\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function sample(notifier) {\n    return (source) => source.lift(new SampleOperator(notifier));\n}\nclass SampleOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const sampleSubscriber = new SampleSubscriber(subscriber);\n        const subscription = source.subscribe(sampleSubscriber);\n        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));\n        return subscription;\n    }\n}\nclass SampleSubscriber extends SimpleOuterSubscriber {\n    constructor() {\n        super(...arguments);\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n    }\n    notifyNext() {\n        this.emitValue();\n    }\n    notifyComplete() {\n        this.emitValue();\n    }\n    emitValue() {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function sampleTime(period, scheduler = async) {\n    return (source) => source.lift(new SampleTimeOperator(period, scheduler));\n}\nclass SampleTimeOperator {\n    constructor(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    }\n}\nclass SampleTimeSubscriber extends Subscriber {\n    constructor(destination, period, scheduler) {\n        super(destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n    }\n    _next(value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    }\n    notifyNext() {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    }\n}\nfunction dispatchNotification(state) {\n    let { subscriber, period } = state;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n","import { Subscriber } from '../Subscriber';\nexport function sequenceEqual(compareTo, comparator) {\n    return (source) => source.lift(new SequenceEqualOperator(compareTo, comparator));\n}\nexport class SequenceEqualOperator {\n    constructor(compareTo, comparator) {\n        this.compareTo = compareTo;\n        this.comparator = comparator;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));\n    }\n}\nexport class SequenceEqualSubscriber extends Subscriber {\n    constructor(destination, compareTo, comparator) {\n        super(destination);\n        this.compareTo = compareTo;\n        this.comparator = comparator;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    _next(value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    }\n    _complete() {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n        this.unsubscribe();\n    }\n    checkValues() {\n        const { _a, _b, comparator } = this;\n        while (_a.length > 0 && _b.length > 0) {\n            let a = _a.shift();\n            let b = _b.shift();\n            let areEqual = false;\n            try {\n                areEqual = comparator ? comparator(a, b) : a === b;\n            }\n            catch (e) {\n                this.destination.error(e);\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    }\n    emit(value) {\n        const { destination } = this;\n        destination.next(value);\n        destination.complete();\n    }\n    nextB(value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    }\n    completeB() {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    }\n}\nclass SequenceEqualCompareToSubscriber extends Subscriber {\n    constructor(destination, parent) {\n        super(destination);\n        this.parent = parent;\n    }\n    _next(value) {\n        this.parent.nextB(value);\n    }\n    _error(err) {\n        this.parent.error(err);\n        this.unsubscribe();\n    }\n    _complete() {\n        this.parent.completeB();\n        this.unsubscribe();\n    }\n}\n","import { ReplaySubject } from '../ReplaySubject';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    let config;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        config = configOrBufferSize;\n    }\n    else {\n        config = {\n            bufferSize: configOrBufferSize,\n            windowTime,\n            refCount: false,\n            scheduler,\n        };\n    }\n    return (source) => source.lift(shareReplayOperator(config));\n}\nfunction shareReplayOperator({ bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, refCount: useRefCount, scheduler, }) {\n    let subject;\n    let refCount = 0;\n    let subscription;\n    let hasError = false;\n    let isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        let innerSub;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n            innerSub = subject.subscribe(this);\n            subscription = source.subscribe({\n                next(value) {\n                    subject.next(value);\n                },\n                error(err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete() {\n                    isComplete = true;\n                    subscription = undefined;\n                    subject.complete();\n                },\n            });\n            if (isComplete) {\n                subscription = undefined;\n            }\n        }\n        else {\n            innerSub = subject.subscribe(this);\n        }\n        this.add(() => {\n            refCount--;\n            innerSub.unsubscribe();\n            innerSub = undefined;\n            if (subscription && !isComplete && useRefCount && refCount === 0) {\n                subscription.unsubscribe();\n                subscription = undefined;\n                subject = undefined;\n            }\n        });\n    };\n}\n","import { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nexport function single(predicate) {\n    return (source) => source.lift(new SingleOperator(predicate, source));\n}\nclass SingleOperator {\n    constructor(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    }\n}\nclass SingleSubscriber extends Subscriber {\n    constructor(destination, predicate, source) {\n        super(destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    applySingleValue(value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    }\n    _next(value) {\n        const index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    }\n    tryNext(value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        const destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError);\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function skip(count) {\n    return (source) => source.lift(new SkipOperator(count));\n}\nclass SkipOperator {\n    constructor(total) {\n        this.total = total;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    }\n}\nclass SkipSubscriber extends Subscriber {\n    constructor(destination, total) {\n        super(destination);\n        this.total = total;\n        this.count = 0;\n    }\n    _next(x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nexport function skipLast(count) {\n    return (source) => source.lift(new SkipLastOperator(count));\n}\nclass SkipLastOperator {\n    constructor(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError;\n        }\n    }\n    call(subscriber, source) {\n        if (this._skipCount === 0) {\n            return source.subscribe(new Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    }\n}\nclass SkipLastSubscriber extends Subscriber {\n    constructor(destination, _skipCount) {\n        super(destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    _next(value) {\n        const skipCount = this._skipCount;\n        const count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            const currentIndex = count % skipCount;\n            const ring = this._ring;\n            const oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    }\n}\n","import { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function skipUntil(notifier) {\n    return (source) => source.lift(new SkipUntilOperator(notifier));\n}\nclass SkipUntilOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(destination, source) {\n        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));\n    }\n}\nclass SkipUntilSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, notifier) {\n        super(destination);\n        this.hasValue = false;\n        const innerSubscriber = new SimpleInnerSubscriber(this);\n        this.add(innerSubscriber);\n        this.innerSubscription = innerSubscriber;\n        const innerSubscription = innerSubscribe(notifier, innerSubscriber);\n        if (innerSubscription !== innerSubscriber) {\n            this.add(innerSubscription);\n            this.innerSubscription = innerSubscription;\n        }\n    }\n    _next(value) {\n        if (this.hasValue) {\n            super._next(value);\n        }\n    }\n    notifyNext() {\n        this.hasValue = true;\n        if (this.innerSubscription) {\n            this.innerSubscription.unsubscribe();\n        }\n    }\n    notifyComplete() {\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function skipWhile(predicate) {\n    return (source) => source.lift(new SkipWhileOperator(predicate));\n}\nclass SkipWhileOperator {\n    constructor(predicate) {\n        this.predicate = predicate;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    }\n}\nclass SkipWhileSubscriber extends Subscriber {\n    constructor(destination, predicate) {\n        super(destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    _next(value) {\n        const destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    }\n    tryCallPredicate(value) {\n        try {\n            const result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n}\n","import { SubscribeOnObservable } from '../observable/SubscribeOnObservable';\nexport function subscribeOn(scheduler, delay = 0) {\n    return function subscribeOnOperatorFunction(source) {\n        return source.lift(new SubscribeOnOperator(scheduler, delay));\n    };\n}\nclass SubscribeOnOperator {\n    constructor(scheduler, delay) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    call(subscriber, source) {\n        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n    }\n}\n","import { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\nexport function switchAll() {\n    return switchMap(identity);\n}\n","import { switchMap } from './switchMap';\nexport function switchMapTo(innerObservable, resultSelector) {\n    return resultSelector ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { innerSubscribe, SimpleInnerSubscriber, SimpleOuterSubscriber } from '../innerSubscribe';\nexport function takeUntil(notifier) {\n    return (source) => source.lift(new TakeUntilOperator(notifier));\n}\nclass TakeUntilOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n        const notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));\n        if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n            takeUntilSubscriber.add(notifierSubscription);\n            return source.subscribe(takeUntilSubscriber);\n        }\n        return takeUntilSubscriber;\n    }\n}\nclass TakeUntilSubscriber extends SimpleOuterSubscriber {\n    constructor(destination) {\n        super(destination);\n        this.seenValue = false;\n    }\n    notifyNext() {\n        this.seenValue = true;\n        this.complete();\n    }\n    notifyComplete() {\n    }\n}\n","import { Subscriber } from '../Subscriber';\nexport function takeWhile(predicate, inclusive = false) {\n    return (source) => source.lift(new TakeWhileOperator(predicate, inclusive));\n}\nclass TakeWhileOperator {\n    constructor(predicate, inclusive) {\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n    }\n}\nclass TakeWhileSubscriber extends Subscriber {\n    constructor(destination, predicate, inclusive) {\n        super(destination);\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n        this.index = 0;\n    }\n    _next(value) {\n        const destination = this.destination;\n        let result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    }\n    nextOrComplete(value, predicateResult) {\n        const destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            if (this.inclusive) {\n                destination.next(value);\n            }\n            destination.complete();\n        }\n    }\n}\n","import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport const defaultThrottleConfig = {\n    leading: true,\n    trailing: false\n};\nexport function throttle(durationSelector, config = defaultThrottleConfig) {\n    return (source) => source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));\n}\nclass ThrottleOperator {\n    constructor(durationSelector, leading, trailing) {\n        this.durationSelector = durationSelector;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n    }\n}\nclass ThrottleSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, durationSelector, _leading, _trailing) {\n        super(destination);\n        this.destination = destination;\n        this.durationSelector = durationSelector;\n        this._leading = _leading;\n        this._trailing = _trailing;\n        this._hasValue = false;\n    }\n    _next(value) {\n        this._hasValue = true;\n        this._sendValue = value;\n        if (!this._throttled) {\n            if (this._leading) {\n                this.send();\n            }\n            else {\n                this.throttle(value);\n            }\n        }\n    }\n    send() {\n        const { _hasValue, _sendValue } = this;\n        if (_hasValue) {\n            this.destination.next(_sendValue);\n            this.throttle(_sendValue);\n        }\n        this._hasValue = false;\n        this._sendValue = undefined;\n    }\n    throttle(value) {\n        const duration = this.tryDurationSelector(value);\n        if (!!duration) {\n            this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));\n        }\n    }\n    tryDurationSelector(value) {\n        try {\n            return this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return null;\n        }\n    }\n    throttlingDone() {\n        const { _throttled, _trailing } = this;\n        if (_throttled) {\n            _throttled.unsubscribe();\n        }\n        this._throttled = undefined;\n        if (_trailing) {\n            this.send();\n        }\n    }\n    notifyNext() {\n        this.throttlingDone();\n    }\n    notifyComplete() {\n        this.throttlingDone();\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { defaultThrottleConfig } from './throttle';\nexport function throttleTime(duration, scheduler = async, config = defaultThrottleConfig) {\n    return (source) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\nclass ThrottleTimeOperator {\n    constructor(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    }\n}\nclass ThrottleTimeSubscriber extends Subscriber {\n    constructor(destination, duration, scheduler, leading, trailing) {\n        super(destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    _next(value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n            else if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n    }\n    _complete() {\n        if (this._hasTrailingValue) {\n            this.destination.next(this._trailingValue);\n            this.destination.complete();\n        }\n        else {\n            this.destination.complete();\n        }\n    }\n    clearThrottle() {\n        const throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    }\n}\nfunction dispatchNext(arg) {\n    const { subscriber } = arg;\n    subscriber.clearThrottle();\n}\n","import { async } from '../scheduler/async';\nimport { scan } from './scan';\nimport { defer } from '../observable/defer';\nimport { map } from './map';\nexport function timeInterval(scheduler = async) {\n    return (source) => defer(() => {\n        return source.pipe(scan(({ current }, value) => ({ value, current: scheduler.now(), last: current }), { current: scheduler.now(), value: undefined, last: undefined }), map(({ current, last, value }) => new TimeInterval(value, current - last)));\n    });\n}\nexport class TimeInterval {\n    constructor(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n}\n","import { async } from '../scheduler/async';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { timeoutWith } from './timeoutWith';\nimport { throwError } from '../observable/throwError';\nexport function timeout(due, scheduler = async) {\n    return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function timeoutWith(due, withObservable, scheduler = async) {\n    return (source) => {\n        let absoluteTimeout = isDate(due);\n        let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nclass TimeoutWithOperator {\n    constructor(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    }\n}\nclass TimeoutWithSubscriber extends SimpleOuterSubscriber {\n    constructor(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        super(destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.scheduleTimeout();\n    }\n    static dispatchTimeout(subscriber) {\n        const { withObservable } = subscriber;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n    }\n    scheduleTimeout() {\n        const { action } = this;\n        if (action) {\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    }\n    _next(value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        super._next(value);\n    }\n    _unsubscribe() {\n        this.action = undefined;\n        this.scheduler = null;\n        this.withObservable = null;\n    }\n}\n","import { async } from '../scheduler/async';\nimport { map } from './map';\nexport function timestamp(scheduler = async) {\n    return map((value) => new Timestamp(value, scheduler.now()));\n}\nexport class Timestamp {\n    constructor(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n}\n","import { reduce } from './reduce';\nfunction toArrayReducer(arr, item, index) {\n    if (index === 0) {\n        return [item];\n    }\n    arr.push(item);\n    return arr;\n}\nexport function toArray() {\n    return reduce(toArrayReducer, []);\n}\n","import { Subject } from '../Subject';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nclass WindowOperator {\n    constructor(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    call(subscriber, source) {\n        const windowSubscriber = new WindowSubscriber(subscriber);\n        const sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));\n        }\n        return sourceSubscription;\n    }\n}\nclass WindowSubscriber extends SimpleOuterSubscriber {\n    constructor(destination) {\n        super(destination);\n        this.window = new Subject();\n        destination.next(this.window);\n    }\n    notifyNext() {\n        this.openWindow();\n    }\n    notifyError(error) {\n        this._error(error);\n    }\n    notifyComplete() {\n        this._complete();\n    }\n    _next(value) {\n        this.window.next(value);\n    }\n    _error(err) {\n        this.window.error(err);\n        this.destination.error(err);\n    }\n    _complete() {\n        this.window.complete();\n        this.destination.complete();\n    }\n    _unsubscribe() {\n        this.window = null;\n    }\n    openWindow() {\n        const prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        const destination = this.destination;\n        const newWindow = this.window = new Subject();\n        destination.next(newWindow);\n    }\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\nexport function windowCount(windowSize, startWindowEvery = 0) {\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nclass WindowCountOperator {\n    constructor(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    }\n}\nclass WindowCountSubscriber extends Subscriber {\n    constructor(destination, windowSize, startWindowEvery) {\n        super(destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    _next(value) {\n        const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        const destination = this.destination;\n        const windowSize = this.windowSize;\n        const windows = this.windows;\n        const len = windows.length;\n        for (let i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        const c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            const window = new Subject();\n            windows.push(window);\n            destination.next(window);\n        }\n    }\n    _error(err) {\n        const windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    }\n    _unsubscribe() {\n        this.count = 0;\n        this.windows = null;\n    }\n}\n","import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    let scheduler = async;\n    let windowCreationInterval = null;\n    let maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = Number(arguments[2]);\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = Number(arguments[1]);\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nclass WindowTimeOperator {\n    constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    }\n}\nclass CountedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this._numberOfNextedValues = 0;\n    }\n    next(value) {\n        this._numberOfNextedValues++;\n        super.next(value);\n    }\n    get numberOfNextedValues() {\n        return this._numberOfNextedValues;\n    }\n}\nclass WindowTimeSubscriber extends Subscriber {\n    constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        super(destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        const window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            const closeState = { subscriber: this, window, context: null };\n            const creationState = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            const timeSpanOnlyState = { subscriber: this, window, windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    _next(value) {\n        const windows = this.windows;\n        const len = windows.length;\n        for (let i = 0; i < len; i++) {\n            const window = windows[i];\n            if (!window.closed) {\n                window.next(value);\n                if (window.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window);\n                }\n            }\n        }\n    }\n    _error(err) {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            const window = windows.shift();\n            if (!window.closed) {\n                window.complete();\n            }\n        }\n        this.destination.complete();\n    }\n    openWindow() {\n        const window = new CountedSubject();\n        this.windows.push(window);\n        const destination = this.destination;\n        destination.next(window);\n        return window;\n    }\n    closeWindow(window) {\n        window.complete();\n        const windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    }\n}\nfunction dispatchWindowTimeSpanOnly(state) {\n    const { subscriber, windowTimeSpan, window } = state;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n    const window = subscriber.openWindow();\n    const action = this;\n    let context = { action, subscription: null };\n    const timeSpanState = { subscriber, window, context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    const { subscriber, window, context } = state;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n","import { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function windowToggle(openings, closingSelector) {\n    return (source) => source.lift(new WindowToggleOperator(openings, closingSelector));\n}\nclass WindowToggleOperator {\n    constructor(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    }\n}\nclass WindowToggleSubscriber extends OuterSubscriber {\n    constructor(destination, openings, closingSelector) {\n        super(destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult(this, openings, openings));\n    }\n    _next(value) {\n        const { contexts } = this;\n        if (contexts) {\n            const len = contexts.length;\n            for (let i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    }\n    _error(err) {\n        const { contexts } = this;\n        this.contexts = null;\n        if (contexts) {\n            const len = contexts.length;\n            let index = -1;\n            while (++index < len) {\n                const context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        super._error(err);\n    }\n    _complete() {\n        const { contexts } = this;\n        this.contexts = null;\n        if (contexts) {\n            const len = contexts.length;\n            let index = -1;\n            while (++index < len) {\n                const context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        const { contexts } = this;\n        this.contexts = null;\n        if (contexts) {\n            const len = contexts.length;\n            let index = -1;\n            while (++index < len) {\n                const context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            let closingNotifier;\n            try {\n                const { closingSelector } = this;\n                closingNotifier = closingSelector(innerValue);\n            }\n            catch (e) {\n                return this.error(e);\n            }\n            const window = new Subject();\n            const subscription = new Subscription();\n            const context = { window, subscription };\n            this.contexts.push(context);\n            const innerSubscription = subscribeToResult(this, closingNotifier, context);\n            if (innerSubscription.closed) {\n                this.closeWindow(this.contexts.length - 1);\n            }\n            else {\n                innerSubscription.context = context;\n                subscription.add(innerSubscription);\n            }\n            this.destination.next(window);\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    }\n    notifyError(err) {\n        this.error(err);\n    }\n    notifyComplete(inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    }\n    closeWindow(index) {\n        if (index === -1) {\n            return;\n        }\n        const { contexts } = this;\n        const context = contexts[index];\n        const { window, subscription } = context;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    }\n}\n","import { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nclass WindowOperator {\n    constructor(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    }\n}\nclass WindowSubscriber extends OuterSubscriber {\n    constructor(destination, closingSelector) {\n        super(destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    notifyNext(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    }\n    notifyError(error) {\n        this._error(error);\n    }\n    notifyComplete(innerSub) {\n        this.openWindow(innerSub);\n    }\n    _next(value) {\n        this.window.next(value);\n    }\n    _error(err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    }\n    _complete() {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    }\n    unsubscribeClosingNotification() {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    }\n    openWindow(innerSub = null) {\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        const prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        const window = this.window = new Subject();\n        this.destination.next(window);\n        let closingNotifier;\n        try {\n            const { closingSelector } = this;\n            closingNotifier = closingSelector();\n        }\n        catch (e) {\n            this.destination.error(e);\n            this.window.error(e);\n            return;\n        }\n        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n    }\n}\n","import { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function withLatestFrom(...args) {\n    return (source) => {\n        let project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        const observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nclass WithLatestFromOperator {\n    constructor(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    }\n}\nclass WithLatestFromSubscriber extends OuterSubscriber {\n    constructor(destination, observables, project) {\n        super(destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        const len = observables.length;\n        this.values = new Array(len);\n        for (let i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (let i = 0; i < len; i++) {\n            let observable = observables[i];\n            this.add(subscribeToResult(this, observable, undefined, i));\n        }\n    }\n    notifyNext(_outerValue, innerValue, outerIndex) {\n        this.values[outerIndex] = innerValue;\n        const toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            const found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    }\n    notifyComplete() {\n    }\n    _next(value) {\n        if (this.toRespond.length === 0) {\n            const args = [value, ...this.values];\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    }\n    _tryProject(args) {\n        let result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\n","import { zip as zipStatic } from '../observable/zip';\nexport function zip(...observables) {\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic(source, ...observables));\n    };\n}\n","import { ZipOperator } from '../observable/zip';\nexport function zipAll(project) {\n    return (source) => source.lift(new ZipOperator(project));\n}\n","import { Subscription } from '../Subscription';\nexport class Action extends Subscription {\n    constructor(scheduler, work) {\n        super();\n    }\n    schedule(state, delay = 0) {\n        return this;\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nexport class AnimationFrameAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nexport class AsapAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AsapScheduler extends AsyncScheduler {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { Action } from './Action';\nexport class AsyncAction extends Action {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    schedule(state, delay = 0) {\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        const id = this.id;\n        const scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    }\n    execute(state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        const error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    }\n    _execute(state, delay) {\n        let errored = false;\n        let errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    }\n    _unsubscribe() {\n        const id = this.id;\n        const scheduler = this.scheduler;\n        const actions = scheduler.actions;\n        const index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    }\n}\n","import { Scheduler } from '../Scheduler';\nexport class AsyncScheduler extends Scheduler {\n    constructor(SchedulerAction, now = Scheduler.now) {\n        super(SchedulerAction, () => {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        });\n        this.actions = [];\n        this.active = false;\n        this.scheduled = undefined;\n    }\n    schedule(work, delay = 0, state) {\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return super.schedule(work, delay, state);\n        }\n    }\n    flush(action) {\n        const { actions } = this;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        let error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nexport class QueueAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    schedule(state, delay = 0) {\n        if (delay > 0) {\n            return super.schedule(state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    }\n    execute(state, delay) {\n        return (delay > 0 || this.closed) ?\n            super.execute(state, delay) :\n            this._execute(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport class VirtualTimeScheduler extends AsyncScheduler {\n    constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {\n        super(SchedulerAction, () => this.frame);\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    flush() {\n        const { actions, maxFrames } = this;\n        let error, action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\nVirtualTimeScheduler.frameTimeFactor = 10;\nexport class VirtualAction extends AsyncAction {\n    constructor(scheduler, work, index = scheduler.index += 1) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.active = true;\n        this.index = scheduler.index = index;\n    }\n    schedule(state, delay = 0) {\n        if (!this.id) {\n            return super.schedule(state, delay);\n        }\n        this.active = false;\n        const action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        this.delay = scheduler.frame + delay;\n        const { actions } = scheduler;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        return undefined;\n    }\n    _execute(state, delay) {\n        if (this.active === true) {\n            return super._execute(state, delay);\n        }\n    }\n    static sortActions(a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport const animationFrame = animationFrameScheduler;\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport const asapScheduler = new AsapScheduler(AsapAction);\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\nexport const async = asyncScheduler;\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport const queueScheduler = new QueueScheduler(QueueAction);\nexport const queue = queueScheduler;\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\nimport { applyMixins } from '../util/applyMixins';\nexport class ColdObservable extends Observable {\n    constructor(messages, scheduler) {\n        super(function (subscriber) {\n            const observable = this;\n            const index = observable.logSubscribedFrame();\n            const subscription = new Subscription();\n            subscription.add(new Subscription(() => {\n                observable.logUnsubscribedFrame(index);\n            }));\n            observable.scheduleMessages(subscriber);\n            return subscription;\n        });\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    scheduleMessages(subscriber) {\n        const messagesLength = this.messages.length;\n        for (let i = 0; i < messagesLength; i++) {\n            const message = this.messages[i];\n            subscriber.add(this.scheduler.schedule(({ message, subscriber }) => { message.notification.observe(subscriber); }, message.frame, { message, subscriber }));\n        }\n    }\n}\napplyMixins(ColdObservable, [SubscriptionLoggable]);\n","import { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { SubscriptionLoggable } from './SubscriptionLoggable';\nimport { applyMixins } from '../util/applyMixins';\nexport class HotObservable extends Subject {\n    constructor(messages, scheduler) {\n        super();\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    _subscribe(subscriber) {\n        const subject = this;\n        const index = subject.logSubscribedFrame();\n        const subscription = new Subscription();\n        subscription.add(new Subscription(() => {\n            subject.logUnsubscribedFrame(index);\n        }));\n        subscription.add(super._subscribe(subscriber));\n        return subscription;\n    }\n    setup() {\n        const subject = this;\n        const messagesLength = subject.messages.length;\n        for (var i = 0; i < messagesLength; i++) {\n            (() => {\n                var message = subject.messages[i];\n                subject.scheduler.schedule(() => { message.notification.observe(subject); }, message.frame);\n            })();\n        }\n    }\n}\napplyMixins(HotObservable, [SubscriptionLoggable]);\n","export class SubscriptionLog {\n    constructor(subscribedFrame, unsubscribedFrame = Number.POSITIVE_INFINITY) {\n        this.subscribedFrame = subscribedFrame;\n        this.unsubscribedFrame = unsubscribedFrame;\n    }\n}\n","import { SubscriptionLog } from './SubscriptionLog';\nexport class SubscriptionLoggable {\n    constructor() {\n        this.subscriptions = [];\n    }\n    logSubscribedFrame() {\n        this.subscriptions.push(new SubscriptionLog(this.scheduler.now()));\n        return this.subscriptions.length - 1;\n    }\n    logUnsubscribedFrame(index) {\n        const subscriptionLogs = this.subscriptions;\n        const oldSubscriptionLog = subscriptionLogs[index];\n        subscriptionLogs[index] = new SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n    }\n}\n","import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n    constructor(assertDeepEqual) {\n        super(VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n        this.runMode = false;\n    }\n    createTime(marbles) {\n        const indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    }\n    createColdObservable(marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const cold = new ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    }\n    createHotObservable(marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const subject = new HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    }\n    materializeInnerObservable(observable, outerFrame) {\n        const messages = [];\n        observable.subscribe((value) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n        }, (err) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n        }, () => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n        });\n        return messages;\n    }\n    expectObservable(observable, subscriptionMarbles = null) {\n        const actual = [];\n        const flushTest = { actual, ready: false };\n        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n        const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?\n            0 : subscriptionParsed.subscribedFrame;\n        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n        let subscription;\n        this.schedule(() => {\n            subscription = observable.subscribe(x => {\n                let value = x;\n                if (x instanceof Observable) {\n                    value = this.materializeInnerObservable(value, this.frame);\n                }\n                actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n            }, (err) => {\n                actual.push({ frame: this.frame, notification: Notification.createError(err) });\n            }, () => {\n                actual.push({ frame: this.frame, notification: Notification.createComplete() });\n            });\n        }, subscriptionFrame);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n            }\n        };\n    }\n    expectSubscriptions(actualSubscriptionLogs) {\n        const flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles) {\n                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n            }\n        };\n    }\n    flush() {\n        const hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        super.flush();\n        this.flushTests = this.flushTests.filter(test => {\n            if (test.ready) {\n                this.assertDeepEqual(test.actual, test.expected);\n                return false;\n            }\n            return true;\n        });\n    }\n    static parseMarblesAsSubscriptions(marbles, runMode = false) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        const len = marbles.length;\n        let groupStart = -1;\n        let subscriptionFrame = Number.POSITIVE_INFINITY;\n        let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        let frame = 0;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    advanceFrameBy(1);\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n            frame = nextFrame;\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    }\n    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        const len = marbles.length;\n        const testMessages = [];\n        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n        let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        const getValue = typeof values !== 'object' ?\n            (x) => x :\n            (x) => {\n                if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        let groupStart = -1;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            let notification;\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '|':\n                    notification = Notification.createComplete();\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    advanceFrameBy(1);\n                    break;\n                case '#':\n                    notification = Notification.createError(errorValue || 'error');\n                    advanceFrameBy(1);\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    notification = Notification.createNext(getValue(c));\n                    advanceFrameBy(1);\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n            }\n            frame = nextFrame;\n        }\n        return testMessages;\n    }\n    run(callback) {\n        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n        const prevMaxFrames = this.maxFrames;\n        TestScheduler.frameTimeFactor = 1;\n        this.maxFrames = Number.POSITIVE_INFINITY;\n        this.runMode = true;\n        AsyncScheduler.delegate = this;\n        const helpers = {\n            cold: this.createColdObservable.bind(this),\n            hot: this.createHotObservable.bind(this),\n            flush: this.flush.bind(this),\n            expectObservable: this.expectObservable.bind(this),\n            expectSubscriptions: this.expectSubscriptions.bind(this),\n        };\n        try {\n            const ret = callback(helpers);\n            this.flush();\n            return ret;\n        }\n        finally {\n            TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n            this.maxFrames = prevMaxFrames;\n            this.runMode = false;\n            AsyncScheduler.delegate = undefined;\n        }\n    }\n}\n","let nextHandle = 1;\nconst RESOLVED = (() => Promise.resolve())();\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport const Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        RESOLVED.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport const TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n","const TimeoutErrorImpl = (() => {\n    function TimeoutErrorImpl() {\n        Error.call(this);\n        this.message = 'Timeout has occurred';\n        this.name = 'TimeoutError';\n        return this;\n    }\n    TimeoutErrorImpl.prototype = Object.create(Error.prototype);\n    return TimeoutErrorImpl;\n})();\nexport const TimeoutError = TimeoutErrorImpl;\n","export function applyMixins(derivedCtor, baseCtors) {\n    for (let i = 0, len = baseCtors.length; i < len; i++) {\n        const baseCtor = baseCtors[i];\n        const propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n        for (let j = 0, len2 = propertyKeys.length; j < len2; j++) {\n            const name = propertyKeys[j];\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        }\n    }\n}\n","export const errorObject = { e: {} };\n","export function isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\n","import { isArray } from './isArray';\nexport function isNumeric(val) {\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n","import { Observable } from '../Observable';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n","export function not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\n","const __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root = __window || __global || __self;\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\nexport { _root as root };\n","import { errorObject } from './errorObject';\nlet tryCatchTarget;\nfunction tryCatcher() {\n    errorObject.e = undefined;\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject.e = e;\n        return errorObject;\n    }\n    finally {\n        tryCatchTarget = undefined;\n    }\n}\nexport function tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n","export { audit } from '../internal/operators/audit';\nexport { auditTime } from '../internal/operators/auditTime';\nexport { buffer } from '../internal/operators/buffer';\nexport { bufferCount } from '../internal/operators/bufferCount';\nexport { bufferTime } from '../internal/operators/bufferTime';\nexport { bufferToggle } from '../internal/operators/bufferToggle';\nexport { bufferWhen } from '../internal/operators/bufferWhen';\nexport { catchError } from '../internal/operators/catchError';\nexport { combineAll } from '../internal/operators/combineAll';\nexport { combineLatest } from '../internal/operators/combineLatest';\nexport { concat } from '../internal/operators/concat';\nexport { concatAll } from '../internal/operators/concatAll';\nexport { concatMap } from '../internal/operators/concatMap';\nexport { concatMapTo } from '../internal/operators/concatMapTo';\nexport { count } from '../internal/operators/count';\nexport { debounce } from '../internal/operators/debounce';\nexport { debounceTime } from '../internal/operators/debounceTime';\nexport { defaultIfEmpty } from '../internal/operators/defaultIfEmpty';\nexport { delay } from '../internal/operators/delay';\nexport { delayWhen } from '../internal/operators/delayWhen';\nexport { dematerialize } from '../internal/operators/dematerialize';\nexport { distinct } from '../internal/operators/distinct';\nexport { distinctUntilChanged } from '../internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from '../internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from '../internal/operators/elementAt';\nexport { endWith } from '../internal/operators/endWith';\nexport { every } from '../internal/operators/every';\nexport { exhaust } from '../internal/operators/exhaust';\nexport { exhaustMap } from '../internal/operators/exhaustMap';\nexport { expand } from '../internal/operators/expand';\nexport { filter } from '../internal/operators/filter';\nexport { finalize } from '../internal/operators/finalize';\nexport { find } from '../internal/operators/find';\nexport { findIndex } from '../internal/operators/findIndex';\nexport { first } from '../internal/operators/first';\nexport { groupBy } from '../internal/operators/groupBy';\nexport { ignoreElements } from '../internal/operators/ignoreElements';\nexport { isEmpty } from '../internal/operators/isEmpty';\nexport { last } from '../internal/operators/last';\nexport { map } from '../internal/operators/map';\nexport { mapTo } from '../internal/operators/mapTo';\nexport { materialize } from '../internal/operators/materialize';\nexport { max } from '../internal/operators/max';\nexport { merge } from '../internal/operators/merge';\nexport { mergeAll } from '../internal/operators/mergeAll';\nexport { mergeMap, flatMap } from '../internal/operators/mergeMap';\nexport { mergeMapTo } from '../internal/operators/mergeMapTo';\nexport { mergeScan } from '../internal/operators/mergeScan';\nexport { min } from '../internal/operators/min';\nexport { multicast } from '../internal/operators/multicast';\nexport { observeOn } from '../internal/operators/observeOn';\nexport { onErrorResumeNext } from '../internal/operators/onErrorResumeNext';\nexport { pairwise } from '../internal/operators/pairwise';\nexport { partition } from '../internal/operators/partition';\nexport { pluck } from '../internal/operators/pluck';\nexport { publish } from '../internal/operators/publish';\nexport { publishBehavior } from '../internal/operators/publishBehavior';\nexport { publishLast } from '../internal/operators/publishLast';\nexport { publishReplay } from '../internal/operators/publishReplay';\nexport { race } from '../internal/operators/race';\nexport { reduce } from '../internal/operators/reduce';\nexport { repeat } from '../internal/operators/repeat';\nexport { repeatWhen } from '../internal/operators/repeatWhen';\nexport { retry } from '../internal/operators/retry';\nexport { retryWhen } from '../internal/operators/retryWhen';\nexport { refCount } from '../internal/operators/refCount';\nexport { sample } from '../internal/operators/sample';\nexport { sampleTime } from '../internal/operators/sampleTime';\nexport { scan } from '../internal/operators/scan';\nexport { sequenceEqual } from '../internal/operators/sequenceEqual';\nexport { share } from '../internal/operators/share';\nexport { shareReplay } from '../internal/operators/shareReplay';\nexport { single } from '../internal/operators/single';\nexport { skip } from '../internal/operators/skip';\nexport { skipLast } from '../internal/operators/skipLast';\nexport { skipUntil } from '../internal/operators/skipUntil';\nexport { skipWhile } from '../internal/operators/skipWhile';\nexport { startWith } from '../internal/operators/startWith';\nexport { subscribeOn } from '../internal/operators/subscribeOn';\nexport { switchAll } from '../internal/operators/switchAll';\nexport { switchMap } from '../internal/operators/switchMap';\nexport { switchMapTo } from '../internal/operators/switchMapTo';\nexport { take } from '../internal/operators/take';\nexport { takeLast } from '../internal/operators/takeLast';\nexport { takeUntil } from '../internal/operators/takeUntil';\nexport { takeWhile } from '../internal/operators/takeWhile';\nexport { tap } from '../internal/operators/tap';\nexport { throttle } from '../internal/operators/throttle';\nexport { throttleTime } from '../internal/operators/throttleTime';\nexport { throwIfEmpty } from '../internal/operators/throwIfEmpty';\nexport { timeInterval } from '../internal/operators/timeInterval';\nexport { timeout } from '../internal/operators/timeout';\nexport { timeoutWith } from '../internal/operators/timeoutWith';\nexport { timestamp } from '../internal/operators/timestamp';\nexport { toArray } from '../internal/operators/toArray';\nexport { window } from '../internal/operators/window';\nexport { windowCount } from '../internal/operators/windowCount';\nexport { windowTime } from '../internal/operators/windowTime';\nexport { windowToggle } from '../internal/operators/windowToggle';\nexport { windowWhen } from '../internal/operators/windowWhen';\nexport { withLatestFrom } from '../internal/operators/withLatestFrom';\nexport { zip } from '../internal/operators/zip';\nexport { zipAll } from '../internal/operators/zipAll';\n","export { TestScheduler } from '../internal/testing/TestScheduler';\n","export { webSocket as webSocket } from '../internal/observable/dom/webSocket';\nexport { WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\n"],"names":["Object","defineProperty","exports","value","rxjs_1","require","Observable","Subject","internal_compatibility_1","AnonymousSubject","internal_compatibility_2","config","rxjs_2","Subscription","ReplaySubject","BehaviorSubject","Notification","EmptyError","ArgumentOutOfRangeError","ObjectUnsubscribedError","UnsubscriptionError","pipe","testing_1","TestScheduler","rxjs_3","Subscriber","AsyncSubject","ConnectableObservable","TimeoutError","VirtualTimeScheduler","ajax_1","AjaxResponse","AjaxError","AjaxTimeoutError","rxjs_4","internal_compatibility_3","internal_compatibility_4","TimeInterval","Timestamp","_operators","operators","Scheduler","asap","asapScheduler","queue","queueScheduler","animationFrame","animationFrameScheduler","async","asyncScheduler","Symbol","rxSubscriber","observable","iterator","operators_1","auditTime","duration","scheduler","bufferTime","bufferTimeSpan","length","arguments","isScheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","debounceTime","dueTime","delay","observeOn","sampleTime","period","throttleTime","defaultThrottleConfig","timeInterval","timeout","due","timeoutWith","withObservable","timestamp","windowTime","windowTimeSpan","windowCreationInterval","maxWindowSize","isNumeric"],"sourceRoot":"webpack:///"}